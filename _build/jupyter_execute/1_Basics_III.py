#!/usr/bin/env python
# coding: utf-8

# # 関数とメソッド

# <div name="html-admonition" style="font-size: 0.8em">
# <input type="button" onclick="location.href='https://translate.google.com/translate?hl=&sl=ja&tl=en&u='+window.location;" value="Google translation" style="color:#ffffff;background-color:#008080; height:25px" onmouseover="this.style.background='#99ccff'" onmouseout="this.style.background='#008080'"/> in English or the language of your choice.
# </div><br>

# ## 関数と引数

# コードを書くうえで関数は非常に重要な役割を果たすのが関数である。主に２つのタイプに分けることができる。
# * 組み込み関数（最初から準備されている関数）
# * ユーザー定義の関数（ユーザー自身が作成する関数）
# 
# 名前から想像できるが，プログラミングの関数は数学の関数と非常に似ている。数学の$y=f(x)$という関数を考えてみよう。より具体的に$f(x)=x^2$と置いてみよう。$x$は$-\infty$から$\infty$の実数を取ることができ，それらに対応する$y$の値が返される関数である。`Python`でも同じ関数を簡単に作ることができる。例えば，`func(x)`という関数だとしよう。`Python`では次の用語を使う。
# * `func`：関数名
# * `x`：引数

# 次に，実際に関数を実行し計算するためには$x$に値（例えば，2）を指定する必要がある。数学の関数$f(x)$であれば$f(2)$と置くが，`Python`の関数でも同様に`func(2)`と書き，`4`が返される。この場合，次の用語を使う。
# * **引数値**：引数に指定した値である`2`
# 
# まとめると，引数とは関数を実行する前に定義することになり，引数値を指定することにより関数を実行することができる。

# ## 組み込み関数

# 組み込み関数（built-in functions）とは，ユーザーが使えるように事前に準備された関数である。以下が既出の組込み関数である。
# * `type()`：データ型を調べる
# * `int()`：整数型に変換
# * `float()`：不動小数点型に変換
# * `str()`：文字列型に変換
# * `bool()`：真偽値の確認
# * `list()`：リストの作成（へ変換）
# * `tuple()`：タプルの作成（へ変換）
# 
# 以下では別の基本的な関数を６つ紹介する。

# ### `sum()`

# `sum()`は合計を計算する関数である。引数にリストやタプルを使う。

# In[1]:


gdp_component = [10, 20, 30, 40]

sum(gdp_component)


# ### `abs()`

# 絶対値を返す。`abs`はabsolute value（絶対値）の略。

# In[2]:


abs(10.5)


# In[3]:


abs(-10.5)


# ### `print()`

# `print()`は表示するための関数であり，引数に表示したい値を置く。Jupyter Notebookでは`print()`を使わなくとも出力が表示される。例えば，

# In[4]:


10


# しかし複数行の場合は最後の行しか表示されない。

# In[5]:


10
200


# `print()`を使うと両方を表示することができる。

# In[6]:


print(10)
print(200)


# 異なるオブジェクトを表示するには`,`を使う。

# In[7]:


print('2020年の実質GDP：約', 500+25.7, '兆円')


# 文字列の中で`\n`は改行を示す。

# In[8]:


print('マクロ\n経済学')


# 次に`f-string`を紹介する。文字列の前に`f`を書き加え，文字列の中で`{}`を使うことにより，割り当てた変数の値や計算結果などを表示することが可能となる。次の例を考えよう。

# In[9]:


x = 2/3

print(f'3分の2は{x}です。')


# **四捨五入**し小数点第３位まで表示する場合は，`x`の後に`:.3f`を付け加える。

# In[10]:


print(f'3分の2は約{x:.3f}です。')


# ＜`:.3f`の解釈＞
# * `:`はこの後に続くコードは表示に関するものだと「宣言」している。
# * `.`は小数点表示に関しての設定であることを示している。
# * `3`は小数点第３位を示している。
# * `f`は`float`の`f`
# 
# `3f`を`5f`にすると，小数点第５位までの四捨五入となる。試してみよう。

# 他の引数も指定することができる。次の２つを紹介する。
# * `sep`：
#     * 複数の値を`,`で区切って表示する際，値の間に入る区切り文字を指定する。
#     * デフォルトは半角スペース
# * `end`：
#     * 行末にをどうするかを指定する
#     * デフォルトは`\n`（改行）

# In[11]:


print('A','B','C')
print('A','B','C', sep='')  # 区切り文字なし
print('A','B','C', sep='__')


# In[12]:


print('A','B')
print('A','B', end='')  # 改行なし
print('A', end='___')


# ### `range()`

# `range()`は等差数列のオブジェクトを用意する関数である。次の書き方となる。
# ```
# range(start,stop,step)
# ```
# * `start`：最初の整数（引数を与えない場合は`0`）
# * `stop`：最後の整数の次の値
# * `step`：隣接する整数の差（公差）（引数を与えない場合は`1`）
# 
# 例えば，`0`から`9`までの`10`の整数を生成するには 

# In[13]:


range(10)


# とする。用途が明確ではないと感じるかもしれないが，後述する`for`ループで多用することになる。またリストとして表示するには`list()`を使う。

# In[14]:


x_list = list(range(10))
x_list


# `list()`関数を使って様々な例を表示しよう。

# In[15]:


list(range(4,15+1))


# In[16]:


list(range(4,30+1,2))


# 上の例では`start`$<$`end`となっているが，不等号を逆にして`step`に負の整数を使うと降順の値が並ぶことになる。

# In[17]:


list(range(10,0,-1))


# In[18]:


list(range(10,-10,-2))


# ### `len()`

# 要素の個数などを返す関数であり，引数としてリストやタプル，今後紹介する他のデータ型にも使える。

# In[19]:


l = [0, 1, [2, 3, 4]]
t = (0, 1, (2, 3, 4))
d = {'a':0, 'b':1, 'c':2}


# In[20]:


len(l), len(t), len(d)


# ### `dir()`

# `Python`では全てがオブジェクトと言われており，そのオブジェクトの「中身」を見るための関数が`dir()`（directoryの略）である。使い方は，以下でより詳しく説明する。
# 
# ```{note}
# ここで紹介した関数名は，`type()`関数のように英単語がそのまま使われる場合と，`abs()`関数のように英単語の省略形（absoluteの省略形）となっている場合がある。前者の場合はそのまま読めば良いが，後者の場合はどう発音すれば良いかと気になったりもする。決まった発音方法がある訳ではないので，好きに読めば良いのだが，次のパターンがあるようだ。
# * 省略された単語の発音で読む。
#     * `str()`を「ストリング関数」
# * アルファベットを一文字ずつ読む。
#     * `str()`を「"s","t","r"関数」
#     * `dir()`を「"d","i","r"関数」
# * 省略形を読むパターン。
#     * `len()`は「レン関数」
#     * `dir()`は英単語"dirty"の"dir"と同じアルファベットなので，その発音に合わせて「ダー関数」
#     * 次の章で説明する`elif`はelse ifの省略形となるので「エリフ」と読む人が多いようだ。
#     * このサイトで説明はしないが特殊メソッドと呼ばれるものがあり，その一つに`.__repr__`がある。これを「レパー」と読む人がいる。なぜこうなるかというと，repを「レップ」と読み，rは「アール」だが「ル」は殆ど発音しないので，２つを続けて読むと「レパー」となる。
# ```

# ## ヘルプ

# 組み込み関数`help()`を使うと関数やモジュールなど説明を表示させることができる。例えば，`print()`を例として挙げる。

# In[21]:


help(print)


# 引数は関数名であり`()`は付いていないことに留意しよう。`()`を付けると`print()`を評価した結果に対しての説明が表示されることになる。英語での説明だがパターンを理解すればこれだけでも有用に感じることだろう。 
# 
# `help()`の代わりに`?`を使うこともできる。

# In[22]:


get_ipython().run_line_magic('pinfo', 'print')


# ## ユーザー定義の関数

# ### 基本

# `def`を使って関数を定義し，引数が設定される（省略される場合もある）。ここでは基本となる引数のみを考えるが，引数の**位置**と`=`が重要な役割を果たすことになる。例を使いながら説明しよう。最初の例は数字の2乗を計算する関数である。

# In[23]:


def func_0(x):
    return x**2


# * １行目：
#     * `def`で始まり（`def`はdefinitionの省略形）`:`で終わる。
#     * `func_0`が関数名，`x`が第１引数（ひきすう）であり、この例では唯一の引数である。
# * ２行目：
#     * `return`は評価した値を「戻す」もしくは「返す」という意味。必ず`return`の前にはインデント（通常4つの半角スペース）が必要であり，ないとエラーになる。
#     * `x**2`という戻り値（返り値）の設定をする
# 
# 関数を評価するには，引数に数字を入れて実行する。

# In[24]:


func_0(2)


# 引数が無い関数を定義することを可能である。

# In[25]:


def func_100():
    return 10**2

func_100()


# `print()`関数を追加することもできる。

# In[26]:


def func_kobe(x):
    print('経済学はおもしろい(^o^)/')
    return x**2

func_kobe(10)


# ### 引数の位置が重要

# 引数が複数ある場合にその位置が重要になってくる。次の例を考えよう。

# In[27]:


def func_1(a, b, c):
    return a / b + c


# In[28]:


func_1(10, 2, 10)


# In[29]:


func_1(2, 10, 10)


# ### 実行する際に`=`を使う

# 関数を実行する際、引数に`=`を使って値を指定することも可能である。この場合，引数の順番を変えることが可能となる。

# In[30]:


func_1(10, c=10, b=2)


# `=`が付いていない引数は該当する位置に書く必要があり，`10`が最初に来ないとエラーとなる。一般的なルールとして，`=`を使う引数は全て`()`の右端にまとめる。

# * 関数を実行する際に`=`無しで関数に渡される引数は，その位置が重要であるため**位置引数**と呼ばれる。
# * 関数を実行する際に`=`付きで関数に渡される引数は**キーワード引数**と呼ばれる。

# ### 関数を定義する際に`=`を使う

# 関数を定義する際に`=`を使って引数のデフォルトの値を設定することができる。即ち，引数を入力すると入力された数値を使うが，引数を入力しない場合は引数に予め設定した値（デフォルトの値）が使われて評価される。次の例では`c`のデフォルトの値が`10`に設定されている。

# In[31]:


def func_2(a, b, c=10):
    return sum([a,b])*c


# `c`の値を設定しない場合とする場合を比較してみる。

# In[32]:


func_2(2, 3), func_2(2, 3, 100)


# ````{note}
# 関数を定義する際の引数を「仮引数（parameter）」と呼ばれ，関数を実行する際の引数は「実引数（argument）」と呼ばれる。例として`func_2`関数を考えると，`a`，`b`，`c`は仮引数である。関数を実行する次のコードでは，`2`，`3`，`100`が実引数となる。
# ```
# func_2(2, 3, 100)
# ```
# しかし一般的には両方とも単に「引数」と呼ぶことが多いだろう。
# ````

# ### 戻り値が複数の場合

# (sec:3-unpacking)=
# ### 戻り値が複数の場合

# In[33]:


def func_3(x):
    return x, x**2, x**3

func_3(3)


# この場合、戻り値はタプルとして返される（タプルは`,`で定義されることを思い出そう）。次のコードは，変数`d`に戻り値を割り当てている。

# In[34]:


d = func_3(3)


# `d`を実行すると次の表示となる。

# In[35]:


d


# 従って，次のようにそれぞれの要素にアクセスすることができる。

# In[36]:


d0 = d[0]
d1 = d[1]
d2 = d[2]

print(d0)
print(d1)
print(d2)


# 一方，タプルのアンパッキングという方法を使うと`d0`，`d1`，`d2`への割り当てをより簡単におこなうことができる。アンパッキングを説明するために，次のコードを考えよう。

# In[37]:


e0, e1, e2 = ('神戸', '大学', '経済')

print(e0)
print(e1)
print(e2)


# このコードは次の割り当てを同時におこなっている。
# * `神戸`　→　`e0`
# * `大学`　→　`e1`
# * `経済`　→　`e2`
# 
# アンパッキングとは，「荷物をパッキングする」の反対の意味であり，上のコードは右辺の`()`で囲まれた要素を取り出して（アンパッキングして）左辺の変数に割り当てている。また，タプルはコンマ`,`で定義されるのを思い出そう。従って，右辺の`()`を省いて次のコードでも同じ結果となる。
# ```
# e0, e1, e2 = '神戸', '大学', '経済'
# ```
# これが[](sec:1-multiple-assignment)で説明した`=`の「複数の変数の同時割り当て」である。
# 
# これを利用して，関数`func_3`の実行時に戻り値を`d0`,`d1`,`d2`に同時に割り当てることができる。

# In[38]:


d0, d1, d2 = func_3(3)
print(d0)
print(d1)
print(d2)


# ````{tip}
# 上のコードの左辺もタプルなため，次のように書くこともできる。
# ```
# (d0, d1, d2) = func_3(3)
# ```
# しかしタプルは`,`で定義されるので、`()`を省いても問題ない。
# ````

# ### ドキュメンテーション文字列

# 文字列はシングルクォーテーション`'`もしくはダブルクォーテーション`"`を使い作成するが，それと別にドキュメンテーション文字列（`docstring`）というものがある。こちらも`'`もしくは`"`を使い，複数行にまたがって文字列を作成することができる。次の例は，**the Zen of Python**（`Python`コードを書く上での19の原則）と呼ばれる文章の一部である。

# In[39]:


s = """Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts."""


# In[40]:


print(s)


# この例が示す様に，`print`関数を使うと改行も含めてそのまま表示される。
# 
# これを使ってユーザー定義の関数の説明を付け加えることにより，他人や将来の自分が関数を読む場合に可読性を高めることができる。次のような書き方となる。

# In[41]:


def func_0(x):
    """この関数はxの２乗の値を返す。
    引数：
        x：整数型もしくは不動小数点型
    戻り値：
        xの２乗"""
    return x**2


# また`help()`関数を使うと付け加えて説明が表示されることになる。

# In[42]:


help(func_0)


# ### `lambda`関数

# `def`を使い複雑な関数を定義することができるが，単純な関数の場合，より簡単な方法がある。それが`lambda`関数である。例として，$x^2$を計算する関数を考えよう。
# ```
# def function_name(x):
#     return x**2
# ```
# この関数を`lambda`関数で書き直すと次の様になる。
# ```
# function_name = lambda x: x**2
# ```
# 右辺にある`lambda`は`lambda`関数を定義する部分であり，`def`のように必ず必要である。実際に実行してみよう。

# In[43]:


func_3 = lambda x: x**2


# In[44]:


func_3(2)


# ### 経済学を考える

# #### 将来価値

# * `t`：時間（年; 0,1,2,...）
# * `i`：名目利子率（例えば，0.02）
# * `r`：実質利子率（例えば，0.05）
# * `pi`：インフレ率（例えば，0.03）
# 
# 次の式が成立する。
# 
# $$
# 1+r=\dfrac{1+i}{1+pi}
# $$
# 
# `x`万円を年率`i`%の利息を得る金融商品に投資し，`t`年後に現金化するとしよう。その間のインフレ率は`pi`%とした場合の`x`万円の実質将来価値を計算する関数を考える。

# In[45]:


def future_value(x, i, pi, t):
    r = (1+i)/(1+pi)-1
    return x*(1+r)**t


# In[46]:


future_value(100, 0.05, 0.03, 10)


# #### 現在価値

# `t`年後に`x`万円をもらえるとしよう。`x`万円の現在価値を計算する関数を考える。

# In[47]:


def current_value(x, i, inf, t):
    r = (1+i)/(1+inf)-1
    return x/(1+r)**t


# In[48]:


current_value(100, 0.05, 0.03, 10)


# #### 複利計算

# * `y0`：元金
# * `t`：投資期間
# * `r`：実質利子率（年率）
# * `m`：複利の周期（年間の利息発生回数）
#     * 例えば，毎月利息が発生する場合は`m=12`
# * `yt`：`t`年後の元利合計
# 
# $$
# yt=y0\left( 1+\dfrac{r}{m}  \right)^{mt}
# $$
# 
# `t`年後の元利合計を計算する関数を考えよう。

# In[49]:


def calculate_yt(y0=100, r=0.05, m=1, t=10):
    return y0*( 1+r/m )**(m*t)


# In[50]:


calculate_yt()


# In[51]:


calculate_yt(m=12)


# (object)=

# ## オブジェクトと属性

# `Python`を習うと「オブジェクト」という単語が必ず出てくる。今の内にイメージをつかむために自転車をオブジェクトの例として考えてみよう。通常の自転車には車輪が２つあり、サドルが１つあり、左右にペダルが２つある。これらの数字が自転車に関する**データ**である。またペダルを踏むことにより前に動き、ハンドルを右にきると右方向に進むことになる。即ち、あることを実行すると、ある結果が返されるのである。これは数学の**関数**と同じように理解できる。$y=x^2$の場合、$x$が`2`であれば$y$の値として`4`が返される。このように自転車はデータと関数が備わっているオブジェクトとして考えることができる。また、車輪の数やペダルを踏むことは自転車特有のデータと関数であり、他のオブジェクト（例えば、冷蔵庫）にはない。即ち、世の中の「オブジェクト」にはそれぞれ異なるデータと関数が存在していると考えることができる。
# 
# `Python`の世界でもすべてをこれと同じように考える。コードセルに書いた`10`を実行すると，その`10`がオブジェクトであり，データと関数が備わることになる。それらを**属性**（attributes）と呼ぶ。`10`は単なる数字に見えるが、実は様々な属性から構成されるオブジェクトなのである。上の例の自転車のように、属性は次の２つに分類される。`10`を例にとると、
# 1. `10`が持つ様々な**データ属性**（data attribute）（例えば、`10`という値や整数という情報）
# 1. `10`特有の関数である**メソッド**（method）（例えば、加算、除算のように`10`というデータに働きかける関数）
# 
# を指す（呼称については[Pythonの公式サイト](https://docs.python.org/ja/3/tutorial/classes.html#instance-objects)を参照）。自転車と冷蔵庫は異なるデータと関数を持つように、整数`10`と文字列`マクロ経済学`は異なるデータと関数を備えるオブジェクトなのである。この考え方は`Python`のすべてに当てはまる。即ち、Everything is an object in Python.

# ```{note}
# データ属性もメソッドもオブジェクトの属性には変わりないが，これ以降このサイトではこの２つを次のように呼ぶことにする。
# * データ属性 → 「属性」
# * メソッド → 「メソッド」
# ```

# 属性の例を考えるために浮動小数点型`10.0`を`y`に割り当てよう。

# In[52]:


y = 10.0


# `y`の属性は`dir()`という組み込み関数を使うことにより表示できる。

# In[53]:


dir(y)


# この中の最後にある`real`は数字の実部を表し，実数である`10.0`の実部は`10.0`である。一方，`imag`は複素数の虚部を表すが，`10.0`は複素数ではないので`0.0`になっている。（上で紹介しなかったが，データ型に複素数型もある。）

# In[54]:


y.real, y.imag


# 上の属性のリストにある`_`はアンダースコア（underscore）と呼ぶが，２つ連続した場合`__`となりダブル・アンダースコア（double underscore）と呼ぶ。長いのでダンダー（dunder）と省略する場合が多々ある。ダンダーが付いている属性は`Python`が裏で使うものでありユーザーが直接使う属性ではない。
# 
# 次にメソッドを考えるために次のリストを例に挙げる。

# In[55]:


my_list = [1,2,3]

dir(my_list)


# この中に`append`があるが，`my_list`に要素を追加するメソッドであることは説明した。

# In[56]:


my_list.append(100)

my_list


# ```{note}
# * （データ）属性と異なりメソッドは`()`が必要となる。これは関数の`()`に対応している。`()`を「する」もしくは「実行する」と読めば分かりやすいだろう。
# ```

# ```{hint}
# 関数とメソッドの違いは？役割は基本的には同じだが，次の点で異なる。例えば，`x=[1,2,3]`を考えよう。
# * `sum(x)`の関数`sum()`は`x`から独立して存在する組込み関数であり，`x`に働きかけて合計を返す。
# * `x`のメソッド`append()`は`x`に元々備わっている関数であり，`x`に働きかけて引数に指定された要素を追加する。
# 
# 即ち，オブジェクトに備わっている関数がメソッドとなる。もう一点付け加えると，`x.append()`の場合，裏では`()`の中に`x`が引数として設定されことになる。
# ```

# ## スコープ

# (sec:3-scope)=
# ## スコープ

# ### 説明

# スコープとは、変数が所属し直接アクセスできるコードの中の「領域」を示す。類似する概念に名前空間（Namespace）もあるが、スコープの情報を記す「表」のことであり、スコープ（Scope）と同義と理解すれば良い。
# 
# ここでは基本的に以下のように理解すれば良いであろう。
# 
# * Jupyter Notebookを開始した時点からglobalスコープが始まる。
# * 関数を定義すると、その関数の範囲内でlocalスコープが生成される。
# * globalスコープで定義された変数は、localスコープからアクセスできるが、globalスコープからlocalスコープの変数にはアクセスできない。
# * 関数を実行すると次の順番で変数を探す。
#     1. 関数のローカス・スコープ
#     2. グローバル・スコープ
# 
# 次の例を考えよう。

# In[57]:


s = "Kobe University"  # globalスコープ

def scope_0():
    s = "神戸大学"  # localスコープ
    return s

scope_0()


# この関数を実行すると、Pythonはまず関数`scope_0`のローカル・スコープ内で変数`s`を探すことになる。ローカル・スコープに`s`があるので、それを返している。次の関数を考えよう。

# In[58]:


def scope_1():
    return s

scope_1()


# この例では、まず`Python`はローカル・スコープに`s`があるかを確かめる。ローカル・スコープにないため、次にグローバル・スコープに`s`がないかを確かめている。グローバル・スコープに`s`があったので、それを返している（ないとエラーが出る）。
# 
# 次の例では、グローバル・スコープからローカル・スコープの変数へのアクセスを考える。

# In[59]:


def scope_2():
    s_local = 'Pythonは楽しい(^o^)/'
    return s_local

scope_2()


# `s_local`は関数`scope_2`のローカル・スコープで定義されている。グローバル・スコープからアクセスしようとするとエラーが発生する。

# In[60]:


s_local


# ### 教訓１

# > * 関数内で使う変数は、可能な限り関数内で定義する方が意図しない結果につながるリスクを軽減できる。
# > * グローバル・スコープで定義した変数を関数に使いたい場合は、引数として同じ変数を使う。
# 
# 次の例を考えよう。

# In[61]:


a = 4


# ここで`a`に`4`を割り当てたが，この値を忘れて（知らずに）`10`だったと勘違いして次の関数を定義したとしよう。

# In[62]:


def scope_3(x):
    return x + a


# `scope_3(10)`は`20`を返すと思って実行すると意図しない結果になる。

# In[63]:


scope_3(10)


# このような場合は`a`を引数に使うことにより問題を回避できる。`a`は`10`として関数を実行すると意図した結果となる。

# In[64]:


def scope_4(x,a):
    return x + a

scope_4(10,10)


# この場合、関数`scope_4(x,a)`の`a`はローカス・スコープで定義され、グルーバル・スコープの`a`とは異なる。実際、グルーバル・スコープの`a`の値を確認してみると以前と同じ値`4`である。

# In[65]:


a


# ちなみに、グローバル・スコープの変数名や関数名は`%who`もしくは`%whos`のコマンドで確認できる。

# In[66]:


get_ipython().run_line_magic('who', '')


# このリストにある`s`はグローバル・スコープの`s`である。またローカル・スコープにある`s_local`はこのリストには含まれていない。

# ### 教訓２

# > `for`ループの１行目に使う変数は再割り当てされても構わない変数を使おう。
# 
# `for`ループは次の章で出てくるので，この箇所はスキップして良いだろう。だが，`for`ループを学んだ後，もう一度こちらに戻ってきて読んでみよう。
# 
# 例を使って説明しよう。

# In[67]:


for i in range(5):
    print(i)


# この`for`ループの`i`は`range(5)`の連番`0`、`1`、`2`、`3`、`4`を指す変数として使われるが、グローバル・スコープの変数として存在し、ループの最後の値が割り当てられている。確認してみよう。

# In[68]:


i


# `for`ループで使う変数は、ループ用の変数を使うようにしよう。
