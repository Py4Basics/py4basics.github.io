#!/usr/bin/env python
# coding: utf-8

# # モジュールと疑似コード

# ## モジュールとパッケージ

# ### 説明

# Pythonには組み込み関数が多く用意されているが，Jupyter Notebookで`Python`のセッションを開始しても全ての関数が使える状態になっていない。使えるようにするためには，モジュール（modules）やパッケージ（package）と呼ばれるものを読み込む必要がある。２つの違いを簡単にいうと次のようになる。
# * モジュール（module）は**１つ**のファイル（拡張子が`.py`）にまとめられた関数群であり，
# * パッケージは（package）**複数**つのファイル（拡張子が`.py`）で構成されている（フォルダーにまとめられている）

# ```{margin}
# <div name="html-admonition">
# Do you want to read in a differnt language? Start
# <input type="button" onclick="location.href='https://translate.google.com/translate?hl=&sl=ja&tl=en&u='+window.location;" value="Google" style="color:#ffffff;background-color:#008080;" onmouseover="this.style.background='#99ccff'" onmouseout="this.style.background='#008080'"/><input type="button" onclick="location.href='https://translate.google.com/translate?hl=&sl=ja&tl=en&u='+window.location;" value="translation" style="color:#ffffff;background-color:#008080;" onmouseover="this.style.background='#99ccff'" onmouseout="this.style.background='#008080'"/>
# in English or the language of your choice.
# </div>
# ```

# 従って，モジュール全体を読み込んだり，あるパッケージの１つのモジュールだけを読み込むということも可能である。授業では，`NumPy`，`SciPy`，`Pandas`を使うが，ここでは例として数学用の`math`モジュール，ランダム変数用の`random`モジュール，オブジェクトの属性を表示する`see`モジュールを取り上げる。
# 
# 含まれる関数を使うためには`import`を使って読み込む必要がある。モジュールの全てを読み込むとモジュール内の全ての関数が使用可能となる。

# ````{note}
# 更に付け加えると，サブパッケージ（subpackage）とサブモジュール（submodule）がある大きなパッケージもある。次の章で説明する[Numpy](chap:numpy)パッケージを例として挙げることができる。フォルダーのの構成で考えると次のようになる。
# ```
# package（フォルダー）
# |-- __init__.py（ファイル）
# |-- module.py（ファイル; 関数が配置）
# |-- subpackage（フォルダー）
#         |-- __init__.py（ファイル）
#         |-- submodule.py（ファイル; 関数が配置）
# ```
# ここで`__init__.py`はパッケージとサブパッケージのフォルダーに必ず必要なファイルであり，空の場合もあれば関数が含まれる場合もある。
# ````

# ### `math`モジュール

# (sec:V-solow)=
# ### `math`モジュール

# 名前が示すように数学に関する関数がまとめられているモジュールとなる（[詳細はこのリンクを参照](https://docs.python.org/ja/3/library/math.html)）。`math`を次のコードで読み込むことができる。

# In[1]:


import math


# 最初の例として平方根を計算してみよう。使う関数名は，square rootの略となる`sqrt()`。

# In[2]:


math.sqrt(4)


# `math.sqrt`とは「`math`モジュールの`sqrt`」という意味であり，`math`をつけるのは他のモジュールの関数`sqrt`とバッティングしないようにするためである。
# 
# モジュール名が長い場合は，短い名前で読み込むことも可能である。

# In[3]:


import math as m


# In[4]:


m.sqrt(9)


# モジュール内の特定の関数だけを読み込むことも可能である。

# In[5]:


from math import sqrt, log   # logは自然対数で, sqrtの両方を読み込む


# このコードは「`math`モジュールから`sqrt`と`log`を読み込む」と読むことができる。

# In[6]:


sqrt(10), log(10)


# ただ、この場合は他のモジュールやパッケージ、もしくは自分が定義した関数をバッティングしないように注意する必要がある。

# ### `random`モジュール

# `random`モジュールを使うことにより乱数を発生させることができる（[詳細はこのリンクを参照](https://docs.python.org/ja/3/library/random.html)）。まず`random`をインポートしよう。

# In[7]:


import random


# 様々な関数が用意されているが，その中の`randint()`関数は，引数で指定するランダムな整数を返す。
# * 第１引数：最小値（整数型）
# * 第２引数：最大値（整数型）
# 
# 次のコードは$[1,10]$の間の整数を返す。`1`と`10`は戻り値に含まれることに注意しよう。
# ```
# random.randint(1, 10)
# ```
# 
# では実際にコードを実行してみよう。次のコードはサイコロの目（1~6）を１つを返す。

# In[8]:


random.randint(1,6)


# 内包表記を使って10回サイコロを振った結果を表示してみよう。

# In[9]:


[random.randint(1,6) for _ in range(10)]


# ````{note}
# 内包表記に`_`（アンダースコア）を使っている。`i`や`j`を使っても良いが，回数を数える以外に役目はない。その様な場合に良く使われるのが`_`である。`for`ループでも同じことが言える。次のコードが例として挙げられる。
# ```
# for _ in range(5):
#     print('hello')
# ```
# ２行目に`_`は入っていないので，ループの回数を数える以外の役割はない。
# ````

# 次に，`gauss()`を紹介する。この関数は，正規分布から生成されたランダム変数を１つ返す。引数は次の様になっている。
# * 第１引数：平均値
# * 第２引数：標準偏差
# 
# 従って，次のコードは標準正規分布からのランダム変数を生成する。
# 
# ```
# random.gauss(0, 1)
# ```
# 関数名が`gauss`なのは，正規分布はガウス分布とも呼ばれるためである。
# 
# 
# 次のコードは，平均`10`，標準偏差`2`からランダム変数を生成している。

# In[10]:


random.gauss(10,2)


# 内包表記を使って，標準正規分布から生成された`10`のランダム変数からなるリストを作成しよう。

# In[11]:


[random.gauss(0,1) for _ in range(10)]


# ### `see`モジュール

# [オブジェクトと属性](object)の節で属性を確認する`dir()`関数について説明した。`dir()`は組み込み関数であるため，パッケージやモジュールをインポートしなくても使えるので便利である。しかし通常使う必要がない`__`（`_`が２つ並んでいる）が付いている属性（例えば，`.__init__`）まで表示されてしまう。それらを省いて，属性のリストを見やすく表示するのが`see`モジュールである。
# 
# ```{hint}
# `_`はunderscoreと読む。`_`が2つ並んだ`__`はdouble underscoresだが，略してdunder（ダンダー）と呼ばれる。また，`.__init__`のような属性は特殊属性と呼ばれるが，ダンダー属性と呼ぶこともある。
# ```
# 
# `see`モジュールの使い方は簡単で，まず次のコードでインポートする。

# In[12]:


from see import see


# 後はインポートした関数を`dir()`と同じように使うだけである。簡単な例を考えよう。

# In[13]:


x = 10.99


# `dir()`を使うと通常は必要ないものまで表示される。

# In[14]:


dir(x)


# `see()`を使うとダンダー属性は表示されない。

# In[15]:


see(x)


# `see()`を使う利点がもう一つある。表示されたリストを見ると，メソッドには`()`が付けられているが，単なるデータ属性には付いていない。（表示さている属性・メソッドが全て使えるわけではないので注意しよう）。例えば，`is_integer()`は整数であれば`True`を返すメソッドであり，`.real`と`.imag`は複素数の実部と虚部を返す属性となる。

# In[16]:


x.is_integer()


# In[17]:


x.real, x.imag


# ````{note}
# ここでは`see`関数を直接インポートして使ったが，次のようにインポートすることも可能である。
# ```
# import see
# ```
# 上の例を使うと，この場合は`see.see(x)`として`x`の属性を確認できる。
# ````

# ## アルゴリズム

# コンピューターは`0`と`1`で書かれている機械語しか理解できないが，プログラマーにとって機械語は非常に難解である。つまりプログラマーとコンピューターは直接「会話」ができない。この問題を解決するために，プログラミング言語が開発され「通訳・翻訳」の役割を担っている。`Python`を使う場合は，`Python`コードを書き，それを`Python`が機械語に「通訳」し，コンピューターが命令を実行することになる。結果が表示されると，プログラマーは内容を確認し，コードを追加・修正などをおこない開発が進んでいく。Jupyter Notebookでコードを書く場合でも同じである。
# <pre>
# +--------------+　　Pythonが「通訳」 　+-------+
# |　Pythonコード　| ▷ ▷ ▷ ▷ ▷ ▷ ▷ ▷ ▷　| 機械語　|
# +--------------+   　　　　　　　 　   +-------+
#        ▲                          　  　 ▽
#        ▲                          　　   ▽
#        ▲ アルゴリズム       　　　　　　   　▽ 実  
#        ▲ 疑似コード　　        　      　  ▽ 行  
#        ▲                          　  　 ▽
#        ▲                          　　   ▽
# +-------------+　　　　内容を確認　  　  +-----+
# |　プログラマー　| ◀︎ ◀︎ ◀︎ ◀︎ ◀︎ ◀︎ ◀︎ ◀︎ ◀︎ ◀︎　| 結果 |
# +-------------+     　　　　  　　 　 　+-----+
# 
# ▶︎：プログラマーがおこなう
# ▷：コンピューターがおこなう
# </pre>

# このサイクルの中で**アルゴリズム**は，プログラマーが`Python`コードを書く際に重要な役割を果たす。日本産業規格（JIS X0001）は次のように定義している。
# 
# > 問題を解くためのものであって，明確に定義され，順序付けられた有限個の規則からなる集合
# 
# 平たく言えば，コンピューターが実行すると正しい結果が保証された計算手続である。更に，その計算手続きはどのプログラミング言語でも使える問題解決の明確な考え方である。
# 
# 例えば，カレーを作るとしよう。アルゴリズムはその場合のレシピである。ある程度料理ができる人であれば，書かれている手順に沿って作れば美味しいカレーが出来上がるレシピがアルゴリズムである。様々な問題には異なるアルゴリズムがある。また１つの問題には複数のアルゴリズムが存在する。カレーでも色々なレシピがあるのと同じである。
# 
# ではどのプログラミング言語にも使えるアルゴリズムをどのように表現するのだろう。１つの方法が[フローチャート](https://www.google.co.jp/search?q=%E3%83%95%E3%83%AD%E3%83%BC%E3%83%81%E3%83%A3%E3%83%BC%E3%83%88%E3%80%80%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0)である。そしてもう１つが疑似コードである。以下では疑似コードに基づいてコードの書き方を検討する。

# ## 疑似コード

# 疑似コードとは，自然言語（日本語や英語）で書かれたコードである。`Python`は実行できない箇条書きのような文章となっている。レポートを書く際に，まずアウトラインを考えて書き出す人もいると思うが，それをイメージすれば良いだろう。次の点が重要となる。
# * 明確さ
# * 簡潔さ
# * 細かい詳細は省く
#     * アルゴリズムの核となる部分を捉える
# * 高い可読性
#     * コードを理解できる人ならで誰が読んでも手順が分かるもの
# 
# 一方で，疑似コードの決まった書き方はない。通常は人それぞれ自分のスタイルや好みに合わせて書いているのが実状である（出版のための共通のスタイルがある場合もある）。ここでは次のスタイルとする。
# * `Python`コードと同じインデントを使う。
# * `Python`コード（例えば，`for`や`while`）を使えればそのまま使う。
#     * 疑似コードを英語で書く場合，英語での記述と区別するために大文字を多用するが，日本語とは区別し易いので小文字を使う。
#     
# これら以外は，箇条書きスタイルとしよう。

# ### `FizzBuzz`問題

# まず例として有名な`FizzBuzz`問題を考えよう。
# 
# > 1から100までの数字を表示する。ただし，
# > * 3の倍数は数字の代わりに`Fizz`と表示し，
# > * 5の倍数は数字の代わりに`Buzz`と表示し，
# > * 3と5の倍数は数字の代わりに`FizzBuzz`と表示する。
# 
# 次のコードでは`fizzbuzz`関数として書いている。

# In[18]:


def fizzbuzz():
    
    for i in range(1,100+1):
        
        if i % 3 == 0 and i % 5 == 0:
            print('FizzBuzz')
            
        elif i % 3 == 0:
            print('Fizz')
            
        elif i % 5 == 0:
            print('Buzz')
            
        else:
            print(i)


# ここで`%`は除算の余りを返す演算子である。実行してみよう。

# In[19]:


fizzbuzz()


# これを疑似コードで表してみよう。

# ```
# def フィズバズ（）
# 
#     forループ i <-- 1から100まで
#     
#         if i を3で割ると余り0 and i を5で割ると余り0
#             "FizzBuzz"を表示
#             
#         elif i を3で割ると余り0
#             "Fizz"を表示
#             
#         elif i を5で割ると余り0
#             "Buzz"を表示           
#             
#         else
#             i を表示
# ```

# `Python`コードと疑似コードを比べて，疑似コードがどのようなものかイメージできたのではないだろうか。上にも書いたが，疑似コードの目的はアルゴリズムを表現することであり，`FizzBuzz`の例はその目的を達成している。もちろん，これこそが「正しい」という疑似コードはないので，自分なりに書き替えてみてはどうだろうか。ただ，ここでの目的は質の高い疑似コードを書くことでは**ない**。
# 
# 疑似コードには次の利点がある。
# 
# > プログラミング言語の構文について特に注意を払わずに（エラーを心配せずに），コードの内容を計画・検討することを可能にする。
# 
# この特性を活かして，コードの書き方を検討しようというのがここでの目的である。言い換えると，漠然とした曖昧な疑似コードを**修正する過程**を通して，アルゴリズムを`Python`コードに落とし込むことを考える。５つの例を使うが，疑似コードの修正プロセスがコードを書く上でのヒントになるのではないかと期待している。

# ### リストの合計（`for`ループ）

# ここでの目的：
# > リスト（タプル）の要素の合計を返す関数を作成する。ただし`for`ループを使うこと。

# ---
# ＜Ver. 1＞
# ```
# def 合計(リスト)
# 
#     最初の要素から最後の要素を全て足し合わせる #1
#     
#     その合計を返す
# ```
# * 全体像はイメージできるが，`#1`で要素をどう足し合わせるか不明。要素ごとに何をするかを書き表そう。

# ---
# ＜Ver. 2＞
# ```
# def 合計(リスト)
# 
#     # リストの要素数：N+1
# 
#     0番目の要素に1番目の要素を加える
#     それに2番目の要素を加える。      #1
#     それに3番目の要素を加える。      #1
#     ・・・・・
#     それにN番目の要素を加える。      #1
#     
#     return その合計
# ``` 
# * 具体性が芽生えてきたが，まだコードに落とせない。特に，`#1`にある「それに」をどう扱うかを考えよう。

# ---
# ＜Ver. 3＞
# ```
# def 合計(リスト)
# 
#     # リストの要素数：N+1
# 
#     0番目の要素に1番目の要素を加えて，合計をxとする。 #1
#     xに2番目の要素を加えて，それをxとする。      　 #1
#     xに3番目の要素を加えて，それをxとする。       　#1
#     ・・・・・
#     xにN番目の要素を加えて，それをxとする。      　　#1
#     
#     return x
# ```
# * より具体的になってきたが，`#1`の`x`をどう扱うかを考える必要がある。

# ---
# ＜Ver. 4＞
# ```
# def 合計(リスト)
# 
#     # リストの要素数：N+1
# 
#     x = 0
#     
#     xに0番目の要素の値を足す #1
#     xに1番目の要素の値を足す #1
#     xに2番目の要素の値を足す #1
#     ・・・・・
#     xにN番目の要素の値を足す #1
#     
#     return x
# ```    
# * 骨格ができてきた。`#1`で似た作業がリピートされているのでループを使おう。

# ---
# ＜Ver. 5＞
# ```
# def 合計(リスト)
#     x = 0
#     
#     forループ　i <-- 0からNまで  #1
#         i番目の要素の値をxに足す  #1
#         
#     return x
# ```    
# * `#1`の`i`はリストのインデックス番号になっているが，要素自体で良いのでは？

# ---
# ＜Ver. 6＞
# ```
# def 合計(リスト)
#     x = 0
#     
#     for v <-- リスト
#         要素vをxに足す
#         
#     return x
# ```    
# * ここまで来るとゴールは目の前‼️
# 
# ---

# In[20]:


def sum_for_loop(lst):
    x = 0
    
    for i in lst:
        x += i
    
    return x


# 実行してみよう。

# In[21]:


sum_for_loop([1,2,3]), sum_for_loop(range(0,100))


# ### リストの合計（`while`ループ）

# ここでの目的：
# > リスト（タプル）の要素の合計を返す関数を作成する。ただし`while`ループを使うこと。
# 
# リストの合計（`for`ループ）の＜Ver. 4＞まで同じ。

# ---
# ＜Ver. 4＞
# ```
# def 合計(リスト)
# 
#     # リストの要素数：N+1
# 
#     x = 0
#     
#     xに0番目の要素の値を足す #1
#     xに1番目の要素の値を足す #1
#     xに2番目の要素の値を足す #1
#     ・・・・・
#     xにN番目の要素の値を足す #1
#     
#     return x
# ```    
# * 骨格ができてきた。`#1`で似た作業がリピートされているのでループを使おう。

# ---
# ＜Ver. 5＞
# ```
# def 合計(リスト)
# 
#     x = 0                    #1
#     
#     while 条件                #2
#         i番目の要素の値をxに足す   #3
# 
#     return x
# ```
# * `#2`の条件は何にするのか。
# * 無限ループに入らないように`#1`と`#3`に付け加えることはないか。

# ---
# ＜Ver. 6＞
# ```
# def 合計(リスト)
# 
#     x = 0
#     count = 0                  #1
#     
#     while count < リストの要素数  #2
#         i番目の要素の値をxに足す    #3
#         countを1増やす           #4
# 
#     return x
# ```
# * `#3`の`i`と`#1`，`#2`，`#4`の`count`はどう関係しているのか？同じ？

# ---
# ＜Ver. 7＞
# ```
# def 合計(リスト)
# 
#     x = 0
#     count = 0
#     
#     while count < リストの要素数
#         count番目の要素の値をxに足す
#         countを1増やす
# 
#     return x
# ```
# * ここまで来るとゴールは目の前‼️
# 
# ---

# In[22]:


def sum_while_loop(lst):
    
    x = 0
    count = 0
    
    while count < len(lst):
        x += lst[count]
        count += 1
    
    return x


# 関数を実行しよう。

# In[23]:


sum_while_loop([1,2,3]), sum_while_loop(range(0,100))


# ### コイントス（`for`ループ）

# ここでの目的：
# > `n`回コイントスし，表と裏の回数を表示する関数を作成する。ただし`random.randint()`と`for`ループを使うこと。

# ---
# ＜Ver. 1＞
# ```
# def コイントス(n)
#    
#     0回目のコイントス　→　表・裏  #1
#     1回目のコイントス　→　表・裏  #1
#     2回目のコイントス　→　表・裏  #1
#     ・・・
#     n-1回目のコイントス　→　表・裏   #1
#    
#     表の合計を計算  #2
#     裏の合計を計算  #2
#     
#     表の合計と裏の合計を返す
# ```
# * `#1`で表と裏をどう表す？
# * `#2`の合計の計算はどうする？

# ---
# ＜Ver. 2＞
# ```
# def コイントス(n)
#     
#     # 表：1
#     # 裏：0
#    
#     0回目のコイントス　→　random.randint(0,1)   #1
#     1回目のコイントス　→　random.randint(0,1)   #1
#     2回目のコイントス　→　random.randint(0,1)   #1
#     ・・・
#     n-1回目のコイントス　→　random.randint(0,1) #1
#    
#     表の合計を計算  #2
#     裏の合計を計算  #2
#     
#     表の合計と裏の合計を返す
# ```
# * `#1`は似たコードになるのでループを使おう。
# * `#2`の合計の計算はどうする？

# ---
# ＜Ver. 3＞
# ```
# def コイントス(n)
#     
#     # 表：1
#     # 裏：0
#    
#     for ループ
#         random.randint(0,1)  #1
#    
#     表の合計を計算  #2
#     裏の合計を計算  #2
#     
#     表の合計と裏の合計を返す
# ```
# * `#1`が実行されるたびに`0`又は`1`が出るが，記録されていない。記録する変数を導入する必要がある。
# * その記録を使って`#2`の合計の計算できる。

# ---
# ＜Ver. 4＞
# ```
# def コイントス(n)
#     
#     # 表：1
#     # 裏：0
#    
#     heads = 0
#     tails = 0
#     
#     for ループ                 #1
#         random.randint(0,1)
#         結果が１であれば，headsを１増やす
#         結果が０であれば，tailsを１増やす
#        
#     return heads, tails
# ```
# * `#1`で使うイタラブルは何か？
# * `#1`で使うイタラブル用の変数は何か？

# ---
# ＜Ver. 5＞
# ```
# def コイントス(n)
#     
#     # 表：1
#     # 裏：0
#    
#     heads = 0
#     tails = 0
#     
#     for _ <-- 0からn-1まで            #1
#         random.randint(0,1)
#         結果が１であれば，headsを１増やす  #2
#         結果が０であれば，tailsを１増やす  #2
#        
#     return heads, tails
# ```
# * `#1`で`_`を使っている理由：
#     * `i`や`j`などでも良いが，`for`ループの「本体」で使われていない変数には`_`が使われることがよくある。
# * `#2`を`if`文に書き換える必要がある。

# ---
# ＜Ver. 6＞
# ```
# def コイントス(n)
#     
#     # 表：1
#     # 裏：0
#    
#     heads = 0
#     tails = 0
#     
#     for _ <-- 0からn-1まで
#     
#         random.randint(0,1)の結果をresultに割り当てる
#         
#         if resultが１
#             headsを１増やす
#         
#         else
#             tailsを１増やす
#        
#     return heads, tails
# ```
# * ここまで来ればゴールは目の前‼️
# 
# ---

# In[24]:


def coin_toss_for_loop(n):
    
    heads = 0
    tails = 0
    
    for _ in range(n):
        
        result = random.randint(0,1)
        
        if result == 1:
            heads += 1
            
        else:
            tails += 1
    
    return heads, tails


# 実行しよう

# In[25]:


coin_toss_for_loop(100)


# ### コイントス（`while`ループ）

# ここでの目的：
# > `n`回コイントスし，表と裏の回数を表示する関数を作成する。ただし`random.randint()`と`while`ループを使うこと。
# 
# コイントス（`for`ループ）の＜Ver. 2＞まで同じ。

# ---
# ＜Ver. 2＞
# ```
# def コイントス(n)
#     
#     # 表：1
#     # 裏：0
#    
#     0回目のコイントス　→　random.randint(0,1)   #1
#     1回目のコイントス　→　random.randint(0,1)   #1
#     2回目のコイントス　→　random.randint(0,1)   #1
#     ・・・
#     n-1回目のコイントス　→　random.randint(0,1) #1
#    
#     表の合計を計算  #2
#     裏の合計を計算  #2
#     
#     表の合計と裏の合計を返す
# ```
# * `#1`は似たコードになるのでループを使おう。
# * `#2`の合計の計算はどうする？

# ---
# ＜Ver. 3＞
# ```
# def コイントス(n)
#     
#     # 表：1
#     # 裏：0
#    
#     while ループ
#         random.randint(0,1)  #1
#    
#     表の合計を計算  #2
#     裏の合計を計算  #2
#     
#     表の合計と裏の合計を返す
# ```
# * `#1`で結果を記録する必要がある。
# * その記録を使って`#2`の合計の計算できる。

# ---
# ＜Ver. 4＞
# ```
# def コイントス(n)
#     
#     # 表：1
#     # 裏：0
#     
#     heads = 0
#     tails = 0        #1
#    
#     while 条件　　     #2
#     
#         random.randint(0,1)
#         結果が１であれば，headsを１増やす
#         結果が０であれば，tailsを１増やす  #3
#        
#     return heads, tails
# ```
# * `#2`の条件は何にするのか。
# * 無限ループに入らないように`#1`と`#3`に何を付け加える必要があるか。

# ---
# ＜Ver. 5＞
# ```
# def コイントス(n)
#     
#     heads = 0
#     tails = 0
#     count = 0
# 
#     while count < n
#     
#         random.randint(0,1)
#         結果が１であれば，headsを１増やす  #1
#         結果が０であれば，tailsを１増やす  #1
#         countを1増やす
#        
#     return heads, tails
# ```
# * `#1`を`if`文として書く。

# ---
# ＜Ver. 6＞
# ```
# def コイントス(n)
#     
#     heads = 0
#     tails = 0
#     count = 0
# 
#     while count < n
#     
#         random.randint(0,1)の結果をresultに割り当てる
#         
#         if resultが１
#             headsを１増やす
#         
#         else
#             tailsを１増やす
#             
#         countを1増やす
#        
#     return heads, tails
# ```
# * ここまで来ればゴールは目の前‼️
# 
# ---

# In[26]:


def coin_toss_while_loop(n):
    
    heads = 0
    tails = 0
    count = 0
    
    while count < n:
        
        result = random.randint(0,1)
        
        if result == 1:
            heads += 1
            
        else:
            tails += 1
        
        count += 1
    
    return heads, tails


# コードを実行しよう。

# In[27]:


coin_toss_while_loop(100)


# ### リストの最大値

# ここでの目的：
# > リスト（又はタプル）を引数とし，含まれる要素の中から最大値を返す関数を作成する。

# ---
# ＜Ver. 1＞
# ```
# def 最大値を求める（リスト）:
# 
#     0番目からN番目の要素を比較して最大値を探す  #1
#     
#     最大値を返す
# ```
# * ぼやっとした全体像となっているのは否めない。
# * `#1`の「比較」をどうするかが重要となる。。:

# ---
# ＜Ver. 2＞
# ```
# def 最大値を求める（リスト=l）:
#     
#     # N = リストの要素数
#     
#     <0> l[0]をl[1]〜l[N]と比較し，
#         l[0]が全てに対して大きければ，l[0]が最大値。
#         そうでなければ<1>に進む。
#     <1> l[1]をl[2]〜l[N]と比較し，
#         l[2]が全てに対して大きければ，l[2]が最大値。
#         そうでなければ<2>に進む。
#     <2> l[2]をl[3]〜l[N]と比較し，
#         l[3]が全てに対して大きければ，l[3]が最大値。
#         そうでなければ<3>に進む。
#     ・・・・・
#     <N-1> l[N-1]をl[N]と比較し，
#           l[N-1]大きければ，l[N-1]が最大値。
#           そうでなければl[N]が最大値。
#   
#     最大値を返す
# ```
# 良さそうにも見えるが，問題がある。
# * `<0>`では`N`回の比較をおこなう。
# * `<1>`では`N-1`回の比較をおこなう。
# * `<2>`では`N-2`回の比較をおこなう。
# * ・・・・
# * `<N>`では`1`回の比較をおこなう。
# * 比較する回数の合計は`1+2+3+・・・+N=N(N+1)/2`。比較回数が非常に多い。もっと良い方法があるのでは？

# ---
# ＜Ver. 3＞
# ```
# def 最大値を求める（リスト=l）:
# 
#     # N = リストの要素数
#     
#     l[0]とl[1]を比較し，大きい方を残す    #1
#     l[1]とl[2]を比較し，大きい方を残す    #1
#     l[2]とl[3]を比較し，大きい方を残す    #1
#     ・・・
#     l[N-1]とl[N]を比較し，大きい方を残す  #1
#     
#     最大値を返す
# ```
# * 比較する回数は`N`回で＜Ver. 2＞より少ない。
# * `#1`の「大きい方を残す」はどうする？

# ---
# ＜Ver. 4＞
# ```
# def 最大値を求める（リスト=l）:
# 
#     # N = リストの要素数
# 
#     max_ = -1_000_000        #1
#     
#     l[0]とl[1]を比較し，大きい方をmax_に割り当てる。   #2
#     l[1]とl[2]を比較し，大きい方をmax_に割り当てる。   #2
#     l[2]とl[3]を比較し，大きい方をmax_に割り当てる。   #2
#     ・・・
#     l[N-1]とl[N]を比較し，大きい方をxに割り当てる。 #2
#     
#     return max_
# ```
# * `#2`だけを見ると最大値は求められそう。
# * `#1`では最大値が`-1_000_000`未満の場合をカバーできない。

# ---
# ＜Ver. 5＞
# ```
# def 最大値を求める（リスト=l）:
# 
#     # N = リストの要素数
#     
#     max_ = l[0]
#     
#     max_とl[1]を比較し，大きい方をmax_に割り当てる。  #1
#     max_とl[2]を比較し，大きい方をmax_に割り当てる。  #1
#     max_とl[3]を比較し，大きい方をmax_に割り当てる。  #1
#     ・・・
#     max_とl[N]を比較し，大きい方をmax_に割り当てる。  #1
#     
#     return max_
# ```
# * `#1`は似たようなコードになるのでループを使おう。

# ---
# ＜Ver. 5＞
# ```
# def 最大値を求める（リスト=l）:
# 
#     # N = リストの要素数
#     
#     max_ = l[0]
#     
#     for ループ
#         max_とl[i]を比較し，大きい方をmax_に割り当てる。 #1
#     
#     return max_
# ```
# * `#1`は条件分岐させる必要がある。

# ---
# ＜Ver. 6＞
# ```
# def 最大値を求める（リスト=l）:
# 
#     # N = リストの要素数
#     
#     max_ = l[0]
#     
#     for ループ     #1
#         max_ < l[i]の場合は，l[i]をxに割り当てる。
#         max_ >= l[i]の場合は，pass
#     
#     return max_
# ```
# * `#1`のイタラブルは何にする？
# * `#1`のイタラブル用の変数は何にする？

# ---
# ＜Ver. 7＞
# ```
# def 最大値を求める（リスト=l）:
# 
#     # N = リストの要素数
#     
#     max_ = l[0]
#     
#     for i <-- 0から(lの要素数-1)まで                #1
#         max_ < l[i]の場合は，l[i]をmax_に割り当てる。 #1
#         max_ >= l[i]の場合は，pass                #1
#     
#     return max_
# ```
# * `#1`の`i`はリストのインデックス番号だが，直接要素自体を使う方が`Python`的である。

# ---
# ＜Ver. 8＞
# ```
# def 最大値を求める（リスト=l）:
# 
#     # N = リストの要素数
#     
#     max_ = l[0]
#     
#     for v <-- リスト
#         max_ < vの場合は，vをxに割り当てる。 #1
#         max_ >= vの場合は，pass          #1
#     
#     return max_
# ```
# * `#1`は`if`文に書き換える。

# ---
# ＜Ver. 9＞
# ```
# def 最大値を求める（リスト=l）:
# 
#     max_ = l[0]
#     
#     for v <-- リスト
#     
#         if max_ < v
#             max_にvを割り当てる。
#         else
#             pass
#     
#     return max_
# ```
# * 後は`Python`コードを書くだけ‼️
# 
# ---

# In[28]:


def search_max(l):
    
    max_ = l[0]
    
    for v in l:
        if v > max_:
            max_ = v
        else:         # 省略可
            pass      # 省略可
    
    return max_


# 実行してみよう。

# In[29]:


lst = [random.gauss(0,1) for _ in range(1000)]

search_max(lst)


# ````{note}
# ＜Ver. 2＞をコードで書くと次の様になる。上のコードと比べると実行時間が1000倍近く長くなる。
# ```
# def search_max(l):
#     
#     max_ = l[0]
#     
#     # 最後の要素はカバーしていない
#     for idx, val in enumerate(l[:-1]):
#         
#         temp = max_
#         
# 
#         for k in l[idx+1:]:
#             if val <= k:
#                 continue
#             else:
#                 temp = val
#         
#         if temp > max_:
#             max_ = temp
#     
#     # 最後の要素について
#     if max_ < l[-1]:
#         max_ = l[-1]
# 
#     return max_
# ```
# ````

# ### 最後に

# コードを書くことに慣れてくると，簡単なコードに疑似コードの修正プロセスは必要なくなるだろう。しかし，その段階になればより複雑なコードを書くことになるはずだ。その時には疑似コードが役に立つのではないかと思われる。少し頭をひねるような問題であれば，疑似コードを試してみるのも一案である。
