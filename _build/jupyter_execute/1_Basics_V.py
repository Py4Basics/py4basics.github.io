#!/usr/bin/env python
# coding: utf-8

# # モジュールとアルゴリズム

# <div name="html-admonition" style="font-size: 0.8em">
# <input type="button" onclick="location.href='https://translate.google.com/translate?hl=&sl=ja&tl=en&u='+window.location;" value="Google translation" style="color:#ffffff;background-color:#008080; height:25px" onmouseover="this.style.background='#99ccff'" onmouseout="this.style.background='#008080'"/> in English or the language of your choice.
# </div><br>

# ## モジュールとパッケージ

# ### 説明

# Pythonには組み込み関数が多く用意されているが，Jupyter Notebookで`Python`のセッションを開始しても全ての関数が使える状態になっていない。使えるようにするためには，モジュール（modules）やパッケージ（package）と呼ばれるものを読み込む必要がある。２つの違いを簡単にいうと次のようになる。
# * モジュール（module）は**１つ**のファイル（拡張子が`.py`）にまとめられた関数群であり，
# * パッケージは（package）**複数**つのファイル（拡張子が`.py`）で構成されている（フォルダーにまとめられている）

# 従って，モジュール全体を読み込んだり，あるパッケージの１つのモジュールだけを読み込むということも可能である。授業では，`NumPy`，`SciPy`，`Pandas`を使うが，ここでは例として数学用の`math`モジュール，ランダム変数用の`random`モジュール，オブジェクトの属性を表示する`see`モジュールを取り上げる。
# 
# 含まれる関数を使うためには`import`を使って読み込む必要がある。モジュールの全てを読み込むとモジュール内の全ての関数が使用可能となる。

# ````{note}
# 更に付け加えると，サブパッケージ（subpackage）とサブモジュール（submodule）がある大きなパッケージもある。次の章で説明する[Numpy](chap:numpy)パッケージを例として挙げることができる。フォルダーのの構成で考えると次のようになる。
# ```
# package（フォルダー）
# |-- __init__.py（ファイル）
# |-- module.py（ファイル; 関数が配置）
# |-- subpackage（フォルダー）
#         |-- __init__.py（ファイル）
#         |-- submodule.py（ファイル; 関数が配置）
# ```
# ここで`__init__.py`はパッケージとサブパッケージのフォルダーに必ず必要なファイルであり，空の場合もあれば関数が含まれる場合もある。
# ````

# ### `math`モジュール

# (sec:V-solow)=
# ### `math`モジュール

# 名前が示すように数学に関する関数がまとめられているモジュールとなる（[詳細はこのリンクを参照](https://docs.python.org/ja/3/library/math.html)）。`math`を次のコードで読み込むことができる。

# In[1]:


import math


# 最初の例として平方根を計算してみよう。使う関数名は，square rootの略となる`sqrt()`。

# In[2]:


math.sqrt(4)


# `math.sqrt`とは「`math`モジュールの`sqrt`」という意味であり，`math`をつけるのは他のモジュールの関数`sqrt`とバッティングしないようにするためである。
# 
# モジュール名が長い場合は，短い名前で読み込むことも可能である。

# In[3]:


import math as m


# In[4]:


m.sqrt(9)


# モジュール内の特定の関数だけを読み込むことも可能である。

# In[5]:


from math import sqrt, log   # logは自然対数で, sqrtの両方を読み込む


# このコードは「`math`モジュールから`sqrt`と`log`を読み込む」と読むことができる。

# In[6]:


sqrt(10), log(10)


# ただ、この場合は他のモジュールやパッケージ、もしくは自分が定義した関数をバッティングしないように注意する必要がある。

# ### `random`モジュール

# `random`モジュールを使うことにより乱数を発生させることができる（[詳細はこのリンクを参照](https://docs.python.org/ja/3/library/random.html)）。まず`random`をインポートしよう。

# In[7]:


import random


# 様々な関数が用意されているが，その中の`randint()`関数は，引数で指定するランダムな整数を返す。
# * 第１引数：最小値（整数型）
# * 第２引数：最大値（整数型）
# 
# 次のコードは$[1,10]$の間の整数を返す。`1`と`10`は戻り値に含まれることに注意しよう。
# ```
# random.randint(1, 10)
# ```
# 
# では実際にコードを実行してみよう。次のコードはサイコロの目（1~6）を１つを返す。

# In[8]:


random.randint(1,6)


# 内包表記を使って10回サイコロを振った結果を表示してみよう。

# In[9]:


[random.randint(1,6) for _ in range(10)]


# ````{note}
# 内包表記に`_`（アンダースコア）を使っている。`i`や`j`を使っても良いが，回数を数える以外に役目はない。その様な場合に良く使われるのが`_`である。`for`ループでも同じことが言える。次のコードが例として挙げられる。
# ```
# for _ in range(5):
#     print('hello')
# ```
# ２行目に`_`は入っていないので，ループの回数を数える以外の役割はない。
# ````

# 次に，`gauss()`を紹介する。この関数は，正規分布から生成されたランダム変数を１つ返す。引数は次の様になっている。
# * 第１引数：平均値
# * 第２引数：標準偏差
# 
# 従って，次のコードは標準正規分布からのランダム変数を生成する。
# 
# ```
# random.gauss(0, 1)
# ```
# 関数名が`gauss`なのは，正規分布はガウス分布とも呼ばれるためである。
# 
# 
# 次のコードは，平均`10`，標準偏差`2`からランダム変数を生成している。

# In[10]:


random.gauss(10,2)


# 内包表記を使って，標準正規分布から生成された`10`のランダム変数からなるリストを作成しよう。

# In[11]:


[random.gauss(0,1) for _ in range(10)]


# ### `see`モジュール

# [オブジェクトと属性](object)の節で属性を確認する`dir()`関数について説明した。`dir()`は組み込み関数であるため，パッケージやモジュールをインポートしなくても使えるので便利である。しかし通常使う必要がない`__`（`_`が２つ並んでいる）が付いている属性（例えば，`.__init__`）まで表示されてしまう。それらを省いて，属性のリストを見やすく表示するのが`see`モジュールである。
# 
# ```{hint}
# `_`はunderscoreと読む。`_`が2つ並んだ`__`はdouble underscoresだが，略してdunder（ダンダー）と呼ばれる。また，`.__init__`のような属性は特殊属性と呼ばれるが，ダンダー属性と呼ぶこともある。
# ```
# 
# `see`モジュールの使い方は簡単で，まず次のコードでインポートする。

# In[12]:


from see import see


# 後はインポートした関数を`dir()`と同じように使うだけである。簡単な例を考えよう。

# In[13]:


x = 10.99


# `dir()`を使うと通常は必要ないものまで表示される。

# In[14]:


dir(x)


# `see()`を使うとダンダー属性は表示されない。

# In[15]:


see(x)


# `see()`を使う利点がもう一つある。表示されたリストを見ると，メソッドには`()`が付けられているが，単なるデータ属性には付いていない。（表示さている属性・メソッドが全て使えるわけではないので注意しよう）。例えば，`is_integer()`は整数であれば`True`を返すメソッドであり，`.real`と`.imag`は複素数の実部と虚部を返す属性となる。

# In[16]:


x.is_integer()


# In[17]:


x.real, x.imag


# ````{note}
# ここでは`see`関数を直接インポートして使ったが，次のようにインポートすることも可能である。
# ```
# import see
# ```
# 上の例を使うと，この場合は`see.see(x)`として`x`の属性を確認できる。
# ````

# ## アルゴリズム

# コンピューターは`0`と`1`で書かれている機械語しか理解できないが，プログラマーにとって機械語は非常に難解である。つまりプログラマーとコンピューターは直接「会話」ができない。この問題を解決するために，プログラミング言語が開発され「通訳・翻訳」の役割を担っている。`Python`を使う場合は，`Python`コードを書き，それを`Python`が機械語に「通訳」し，コンピューターが命令を実行することになる。結果が表示されると，プログラマーは内容を確認し，コードを追加・修正などをおこない開発が進んでいく。Jupyter Notebookでコードを書く場合でも同じである。
# <pre>
# +--------------+　　Pythonが「通訳」 　+-------+
# |　Pythonコード　| ▷ ▷ ▷ ▷ ▷ ▷ ▷ ▷ ▷　| 機械語　|
# +--------------+   　　　　　　　 　   +-------+
#        ▲                          　  　 ▽
#        ▲                          　　   ▽
#        ▲ アルゴリズム       　　　　　　   　▽ 実  
#        ▲ 疑似コード　　        　      　  ▽ 行  
#        ▲                          　  　 ▽
#        ▲                          　　   ▽
# +-------------+　　　　内容を確認　  　  +-----+
# |　プログラマー　| ◀︎ ◀︎ ◀︎ ◀︎ ◀︎ ◀︎ ◀︎ ◀︎ ◀︎ ◀︎　| 結果 |
# +-------------+     　　　　  　　 　 　+-----+
# 
# ▶︎：プログラマーがおこなう
# ▷：コンピューターがおこなう
# </pre>

# このサイクルの中で**アルゴリズム**は，プログラマーが`Python`コードを書く際に重要な役割を果たす。日本産業規格（JIS X0001）は次のように定義している。
# 
# > 問題を解くためのものであって，明確に定義され，順序付けられた有限個の規則からなる集合
# 
# 平たく言えば，コンピューターが実行すると正しい結果が保証された計算手続である。更に，その計算手続きはどのプログラミング言語でも使える問題解決の明確な考え方である。
# 
# 例えば，カレーを作るとしよう。アルゴリズムはその場合のレシピである。ある程度料理ができる人であれば，書かれている手順に沿って作れば美味しいカレーが出来上がるレシピがアルゴリズムである。様々な問題には異なるアルゴリズムがある。また１つの問題には複数のアルゴリズムが存在する。カレーでも色々なレシピがあるのと同じである。
# 
# 以下では，比較的に簡単であり，且つ代表的な４つのアルゴリズムについて解説する。また，アルゴリズムによって計算速度が異なり，その理由についても考えることにする。

# ### 例１：合計

# 次のコードは標準正規分布から抽出した100万個のランダム変数から構成されるリストを作成する。

# In[18]:


lst1 = [random.gauss(0,1) for _ in range(10**6)]


# このリストの値を合計するためのアルゴリズムを考える。

# #### `for`ループ

# まず`for`ループを使うアルゴリズムを考えてみよう。

# In[19]:


def sum_for_loop(lst):  #1
    
    x = 0               #2
    
    for i in lst:       #3
        x += i          #4
    
    return x            #5


# ＜コードの説明＞<br>
# * `#1`: 引数はイタラブルであるリストを想定している。
# * `#2`: `for`ループでは`lst`の要素を１つずつ`x`に加算することになるが，その初期値を`0`とする。
# * `#3`: `for`ループの開始
# * `#4`: 累積加算演算子`+=`を使い要素を`x`に加算する。
# * `#5`: `for`ループ終了後に`lst`の要素の合計である`x`を返す。
# 
# 実際に計算してみよう。

# In[20]:


sum_for_loop(lst1)


# #### `while`ループ

# 次に`while`ループを使う場合のコードを考えてみよう。

# In[21]:


def sum_while_loop(lst):     #1
    
    x = 0                    #2
    idx = 0                  #2a
    
    while idx < len(lst):    #3
        
        x += lst[idx]        #4
        idx += 1             #4a
    
    return x                 #5


# ＜コードの説明＞<br>
# * `#1`: 引数はイタラブルであるリストを想定している。
# * `#2`: `for`ループの`x`と同じ役目をする。
# * `#2a`: `while`ループでは，`lst`の要素を抽出する際にインデックス番号を使うことになるが，`idx`（indexの略）はインデックス番号を捉えている。`lst`の最初の項から抽出するために初期値を`0`としている。
# * `#3`: `while`ループが開始され，`idx<len(lst)`が`False`となる時点でループは終了する。例として，`lst=[0,10,20]`としてみよう。`len(lst)`は`3`を返すことになり，`idx`が`3`になると`idx<len(lst)`が`False`となるため，その時点で（`#5`以下は実行されずに）`while`ループは終了する。
# * `#4`: `lst[idx]`では`lst`の`idx`番目の要素を抽出し，それを`+=`を使い`x`に加算する。
# * `#4a`: 次のループで`lst`の次の要素を抽出できるように`idx`を`1`増やし`while`ループを継続する。
# * `#5`: `for`ループ終了後に`lst`の要素の合計である`x`を返す。
# 
# 実際に計算してみよう。

# In[22]:


sum_while_loop(lst1)


# `for`ループと同じ値となっていることが確認できる。

# #### 実行スピード比較

# 次に２つのコードの終了までの時間を比較してみよう。ここでは[マジック・コマンド](https://ipython.readthedocs.io/en/stable/interactive/magics.html)と呼ばれる`%timeit`を使うが，使い方は簡単で行頭に`%timeit`と半角スペースを置いて実行コードを書くだけである。まず`sum_for_loop()`関数を実行してみよう。

# In[23]:


get_ipython().run_line_magic('timeit', 'sum_for_loop(lst1)')


# 表示される結果は，使うPCのスペックなどによって若干異なることになる。
# 結果の解釈方法を説明するため，次のような結果になったとしよう。
# 
# ```
# MMM ms ± NNN µs per loop (mean ± std. dev. of YYY runs, XXX loops each)
# ```
# 
# 次のように解釈する。
# * コードを`XXX`回実行する試行を`YYY`回おこない（合計で`XXX`$\times$`YYY`回），その結果の平均である`mean`は`MMM ms`であり，標準偏差である`std. dev.`は`NNN µs`である。ここで
#     * `ms`：ミリ秒（1/1000秒）
#     * `µs`：マイクロ秒（1/1,000,000秒）
#     * `ns`：ナノ秒（1/1,000,000,000秒; 10億分の１秒）
#     
# * 試行する度に結果が異り，その変動を標準偏差で捉えている。結果は正規分布に従うと仮定すると，約68％の結果が平均$\pm$標準偏差の範囲内に収まることになる。
# 
# 次に`sum_while_loop()`の速度を計測してみよう。

# In[24]:


get_ipython().run_line_magic('timeit', 'sum_while_loop(lst1)')


# `while`ループに比べて`for`ループが約4倍速いことが確認できる。リストから要素を一つずつ抽出し合計するというアルゴリズムでも，コードにどのように表現するかによって速度に大きな違いが発生している。
# 
# では，なぜそのような大きな違いがあるのだろうか。それは次の２つの違いに起因する。
# * `sum_for_loop()`と`sum_while_loop()`の`#3`を考えてみよう。前者の場合，ループ毎に`lst`の要素を`i`に割り当てることを行なっている。一方，後者では，ループ毎に`idx<len(lst)`の条件が満たされているかどうかを確認する必要がある。
# * `sum_while_loop()`では`#2a`と`#4a`が追加されており，「割り当て」と言う意味では`sum_for_loop()`の`#3`と同じである。
# 
# 従って，`while`ループには`idx<len(lst)`が`True`なのか`False`なのかの確認が追加作業となり，それが時間が掛かる要因となっている。
# 
# 最後に，組み込み関数である`sum()`の速度を計測してみよう。

# In[25]:


get_ipython().run_line_magic('timeit', 'sum(lst1)')


# `sum_while_loop()`関数よりも6倍以上も速いことが分かる。組み込み関数は様々なトリックを使い最適化されていることが伺える。

# ````{hint}
# 複数行にまたがるコードの実行スピードを計測する場合は，下の例のように`%%timeit`を１行目に置き，2行目以降にコードを書くと良いだろう。
# ```
# %%timeit
# sum_while_loop(lst1)
# print('Pythonは楽しいね(^o^)/')
# ```
# ````

# ### 例２：値の探索

# 次のコードは`0`から`999,999`までの整数が並ぶリストを作成する。

# In[26]:


lst2 = [i for i in range(1_000_000)]


# ここで考えるのは，`999,000`が`lst2`にあるかどうかを確かめることである。具体的には，`lst2`の最初の要素から一つずつ確認し
# * 見つかれば`1`を返す（探索は途中で終了）
# * 見つからなければ`-1`を返す（最後の要素まで確認する）
# 
# 関数を考える。

# #### `for`ループ

# `for`ループを使うコードを考えよう。

# In[27]:


def search_for_loop(target, lst): #1

    for i in lst:                 #2

        if i == target:           #3
            return 1              #4
            break                 #5
    
    return -1                     #6


# ＜コードの説明＞<br>
# * `#1`: 引数の`target`は探索する数字であり，`lst`はイタラブルであるリストを想定している。
# * `#2`: `for`ループの開始
# * `#3`〜`#5`: `i`が`target`と等しければ`1`を返し，`for`ループは終了する。これで関数の実行は終わり。
# * `#6`: `#2`の`for`ループが`break`されずに終了した場合にのみ実行され`-1`が返される。即ち，`lst`の最後まで探索し，`target`がない場合に実行される行である。
# 
# 実際に計算してみよう。

# In[28]:


search_for_loop(999_000, lst2)


# #### `while`ループ

# 次に`while`ループを使う場合を考えてみよう。

# In[29]:


def search_while_loop(target, lst): #1
    
    idx = 0                         #2

    while True:                     #3
        
        if idx == len(lst):         #4
            return -1               #5
        
        if lst[idx] == target:      #6
            return 1                #7
        
        idx += 1                    #8


# ＜コードの説明＞<br>
# * `#1`: 引数の`target`は探索する数字であり，`lst`はイタラブルであるリストを想定している。
# * `#2`: `while`ループでは，`lst`の要素を抽出する際にインデックス番号を使うことになるが，`idx`（indexの略）はインデックス番号を捉えている。`#4`と`#6`で使う。`lst`の最初の項から抽出するために初期値を`0`としている。
# * `#3`: `while`ループの開始。`#5`もしくは`#7`が実行されるまで`while`ループは継続する。
# * `#4`〜`#5`: `#4`の条件は`lst`の最後の要素まで確認した場合にのみ満たされる。その場合，`-1`が返される。
# * `#6`〜`#7`: `lst`の`idx`番目の要素と`target`が等しい場合に`1`が返される。その時点で関数の実行（`while`ループも含めて）は終了する。
# * `#8`: `#4`と`#5`の条件が`False`であれば，`idx`を`1`増加させて`while`ループを継続する。
# 
# 実際に計算してみよう。

# In[30]:


search_while_loop(999_000, lst2)


# `search_for_loop()`関数と`search_while_loop()`関数の実行スピードを比較してみよう。

# In[31]:


get_ipython().run_line_magic('timeit', 'search_for_loop(999_000, lst2)')


# In[32]:


get_ipython().run_line_magic('timeit', 'search_while_loop(999_000, lst2)')


# `for`ループより`while`ループは4倍以上遅いことがわかる。もう理由は明らかであろう。`search_linear_for()`関数ではループ一回毎に１つの`if`文の条件`#3`を確認する必要があるが，`search_linear_while()`では条件が`#4`と`#6`の２つがある。この確認作業の回数の差が数字として現れている。このことから分かることは，`while`ループであっても条件を１つにすれば速度が倍になると言うことである。それを実現するのが次に考える**番兵法**と呼ばれるアルゴリズムである。

# #### 番兵法

# 番兵法は`while`ループを使うが，次の手続きが必要となる。
# * リストの最後に探索する値を追加する
# 
# `search_while_loop()`関数との違いはこの点だけである。これにより，実質的には`search_linear_while()`の条件`#4`が不要になり実行スピードの高速化される。コードを確認してみよう。

# In[33]:


def search_sentinel(target, lst): #1
    
    size = len(lst)               #2

    lst.append(target)            #3
    
    idx = 0                       #4

    while True:                   #5
        
        if lst[idx] == target:    #6
            break                 #7
            
        idx += 1                  #8

    if idx < size:                #9
        return 1                  #10
    
    else:                         #11
        return -1                 #12


# ＜コードの説明＞<br>
# * `#1`: 引数の`target`は探索する数字であり，`lst`はイタラブルであるリストを想定している。
# * `#2`: `lst`の要素数を`size`に割り当てる。`size`は`#9`で使うことになる。
# * `#3`: `lst`の最後に`target`を追加する。これが「番兵」である。
# * `#4`: `lst`の要素を抽出する際にインデックス番号を使うことになるが，`idx`（indexの略）はインデックス番号を捉えている。`#6`，`#8`，`#9`で使う。`lst`の最初の項から抽出するために初期値を`0`としている。
# * `#5`: `while`ループの開始。
# * `#6`〜`#7`: `lst`の`idx`番目の要素と`target`が等しい場合は`break`を発動させ`while`を中断する。等しくない場合は`#7`を実行せずに`#8`で`idx`を`1`増加さる。`#3`で`target`（番兵）が`lst`に追加されたので，`lst`に`target`がなくても`#6`は必ず満たされて`break`が発動される。これが番兵の役割であり，高速化のための仕込みとなる。
# * `#9`〜`#12`: `while`ループが中断された後に実行される。`#9`の条件が`True`の場合は`lst`に`target`が含まれたと言う意味になるため`1`を返す。一方，`#9`の条件が`False`の場合（即ち，`idx`と`size`は等しい場合），`idx`は番兵のインデックスとなるため`-1`を返す。
# 
# 実際に計算してみよう。

# In[34]:


search_sentinel(999_000, lst2)


# 実行スピードを計測してみよう。

# In[35]:


get_ipython().run_line_magic('timeit', 'search_sentinel(999_000, lst2)')


# `search_while_loop()`関数と比べると約2倍高速化できた。

# #### 組み込み関数

# 組み込み関数に`1`もしくは`-1`を返す関数は見当たらないため，類似するメソッドを考えてみよう。リストには`.index()`というメソッドが用意されており，引数に要素を指定すると，その要素のインデックス番号を返す。試してみよう。

# In[36]:


lst2.index(999_000)


# `999_000`は`lst2`の`999000`番目の要素だという意味。実行速度を計測してみよう。

# In[37]:


get_ipython().run_line_magic('timeit', 'lst2.index(999_000)')


# `search_for_loop()`関数よりも約2倍速い。最適化されていることが伺える。

# ### 例３：最小値の探索

# 次のコードは標準正規分布から抽出した100万個のランダム変数から構成されるリストを作成する。

# In[38]:


lst3 = [random.gauss(0,1) for _ in range(1_000_000)]


# この中から最小値を探索するアルゴリズムを考えてみよう。`lst3`の全ての要素を確認する必要があるので`for`ループを使おう。

# #### 直接的な探索

# まず，リストの最小値を直接探索するコードを考えてみる。

# In[39]:


def search_min(lst):  #1
    
    min_ = lst[0]     #2
    
    for v in lst:     #3
        
        if v < min_:  #4            
            min_ = v  #5
    
    return min_       #6


# ＜コードの説明＞<br>
# * `#1`: 引数`lst`はイタラブルであるリストを想定している。
# * `#2`: `lst`の`0`番目の値を`min_`に割り当てる。`#3`の`for`ループで更に小さな値が発見されれば，`min_`の値と入れ替えることにする。
# * `#3`: `lst`に対する`for`ループの開始。
# * `#4`〜`#5`: `v`が`min_`より小さければ`min_`に割り当てる。そうでなければ，`min_`の値は変えない。
# * `#6`: `for`ループが終わった後（即ち，`lst`の値を全て確認した後），`min_`の値を返す。
# 
# 実際に計算してみよう。

# In[40]:


search_min(lst3)


# #### 間接的な探索

# リストの要素はインデックス番号を使ってアクセスすることができる。それを利用して，上のコードをインデックス番号を使って間接的に要素にアクセスする場合を考える。即ち，最小値のインデックスを探し，最終的に最小値を返す関数となる。

# In[41]:


def search_min_idx(lst):            #1
    
    n_lst = len(lst)                #2
    
    idx_min = 0                     #3
    
    for idx in range(n_lst):        #4
        
        if lst[idx] < lst[idx_min]: #5
            idx_min = idx           #6
    
    return lst[idx_min]             #7


# ＜コードの説明＞<br>
# * `#1`: 引数`lst`はイタラブルであるリストを想定している。
# * `#2`: `lst`の要素数を`n_lst`に割り当てる。`n_lst`は`#4`で使うことになる。
# * `#3`: `idx_min`は最小値の要素のインデックス番号を割り当てる変数として使う。`0`番目の要素から考えるので，初期値として`0`を設定している。
# * `#4`: `range(n_lst)`に対する`for`ループの開始。
# * `#5`〜`#6`: `lst[idx_min]`は，その時点で最小値となる値である。その値より`lst[idx]`が小さい場合，`idx`を`idx_min`に割り当てることにより`idx_min`のインデックス番号を更新する。そうでない場合は`idx_min`の値は変更しない。
# が`min_`より小さければ`min_`に割り当てる。そうでなければ，`min_`の値は変えない。
# * `#7`: `for`ループが終わった後（即ち，`lst`の値を全て確認した後），`idx_min`に対応する要素を返す。
# 
# 実際に計算してみよう。

# In[42]:


search_min_idx(lst3)


# #### 実行スピード比較

# それぞれのコードの実行速度を比べてみよう。

# In[43]:


get_ipython().run_line_magic('timeit', 'search_min(lst3)')


# In[44]:


get_ipython().run_line_magic('timeit', 'search_min_idx(lst3)')


# 間接的にインデックス番号を使うと実行速度を減速させることになる。
# 
# 次に組み込み関数である`min()`と比べてみよう。

# In[45]:


min(lst3)


# In[46]:


get_ipython().run_line_magic('timeit', 'min(lst3)')


# 直接的な方法より2倍以上高速実行されている。

# ### 例４：ソート

# 次のコードは`0`から`999`までの整数をランダムに並べたリストを作成する。

# In[47]:


lst4 = [random.randint(0,1000) for _ in range(1_000)]


# このリストを昇順に並び替えるコードを考える。

# #### 単純選択ソート

# 最初に考えるアルゴリズムである単純選択ソートは次のような考え方に基づいている。

# リストには`0`番目から`n-1`番目の要素があるとしよう。
# * 要素の数は`n`
# * `n>1`とする。
# 
# アルゴリズム（説明をより明確になるようにループを`0`回目から数える。）
# * `0`回目のループ（外側ループ）
#     * `0`番目から最後までの要素の最小値を見つける（内側ループ）
#     * 最小値を`0`番目の要素と入れ替える（値の入れ替え）
# * `1`回目のループ（外側ループ）
#     * `1`番目から最後までの要素の最小値を見つける（内側ループ）
#     * 最小値を`1`番目の要素と入れ替える（値の入れ替え）
# * `2`回目のループ（外側ループ）
#     * `2`番目から最後までの要素の最小値を見つける（内側ループ）
#     * 最小値を`2`番目の要素と入れ替える（値の入れ替え）
# * ......
# * `n-2`回目のループ（外側ループ）
#     * `n-2`番目から最後までの要素の最小値を見つける（内側ループ）
#     * 最小値を`n-2`番目の要素と入れ替える（値の入れ替え）
#     
# （注意）`n-1`回目のループは必要ない。
#     
# この手順に基づくコードを確認しよう。

# In[48]:


def insertion_sort(lst):       #1
    
    n = len(lst)               #2
    
    for i in range(n-1):       #3
        
        i_min = i              #4
        
        for j in range(i+1,n): #5
            
            if lst[j] < lst[i_min]:  #6  
                i_min = j            #7
        
        lst[i], lst[i_min] = lst[i_min], lst[i]  #8
    
    return lst                 #9


# ＜コードの説明＞<br>
# * `#1`: 引数`lst`はイタラブルであるリストを想定している。
# * `#2`: `lst`の要素数を`n`に割り当てる。`n`は`#3`と`#5`で使うことになる。
# * `#3`: 上の説明にある「外側ループ」に対応している。合計で`n-2`回のループ計算をおこなう（最後のインデックス番号である`n-1`を使ったループを考える必要はないため）。
# * `#4`: `i_min`は`#5`の`for`ループ（上の説明にある「内側ループ」）で見つかる最小値を割り当てる変数のインデックス番号として使う。
# * `#5`: 上の説明にある「内側ループ」に対応している。`i`を所与として，`i+1`から`n-1`番目までのループとなる（最小値を探索するためには最後まで確認する必要があるため）。
# * `#6`〜`#7`: `lst[j]`が`lst[i_min]`より小さければ`j`を`i_min`に割り当てる。そうでなければ，`i_min`の値は変えない。
# * `#8`: 上の説明にある「値を入れ替え」に対応している。`#5`の内側ループが終わった後（即ち，`i+1`から`lst`の全ての値を確認した後），`lst[i]`と`lst[i_min]`入れ替えている。
# * `#9`: 外側ループが終わった後，`lst`を返す。
# 
# コードを実行し，最初の`10`の要素を表示してみよう。

# In[49]:


res = insertion_sort(lst4)
res[:10]


# 最後の`10`の要素を表示してみよう。

# In[50]:


res[990:]


# 昇順に並んでいることが確認できる。

# #### バブル・ソート

# 次にバブル・ソートと呼ばれるアルゴリズムを考えてみよう。手順は次の内容となる。

# リストには`0`番目から`n-1`番目の要素があるとしよう。
# * 要素の数は`n`
# * `n>1`とする。
# 
# アルゴリズム（ここではループを`1`回目から数える。）
# * `1`回目のループ（外側ループ）
#     * （以下の手順が内側ループ）
#     * `n-2`番目と`n-1`番目（最後）の要素を比べる
#         * 小さい方を左に，大きい方を右に入れ替える
#         * 同じであれば何もしない
#     * `n-3`番目と`n-2`番目の要素を比べる
#         * 小さい方を左に，大きい方を右に入れ替える
#         * 同じであれば何もしない
#     * ......
#     * `1`番目と`2`番目の要素を比べる
#         * 小さい方を左に，大きい方を右に入れ替える
#         * 同じであれば何もしない
#     * `0`番目と`1`番目の要素を比べる
#     * 小さい方を左に，大きい方を右に入れ替える
#     * 同じであれば何もしない
#     * これで`0`番目の要素は`0`番目から`n-1`番目の要素の最小値となる。
# * `2`回目のループ（外側ループ）
#     * 以下の手順が内側ループ
#     * `n-2`番目と`n-1`番目の要素を比べる
#         * 小さい方を左に，大きい方を右に入れ替える
#         * 同じであれば何もしない
#     * `n-3`番目と`n-2`番目の要素を比べる
#         * 小さい方を左に，大きい方を右に入れ替える
#         * 同じであれば何もしない
#     * ......
#     * `2`番目と`3`番目の要素を比べる
#         * 小さい方を左に，大きい方を右に入れ替える
#         * 同じであれば何もしない
#     * `1`番目と`2`番目の要素を比べる
#         * 小さい方を左に，大きい方を右に入れ替える
#         * 同じであれば何もしない
#     * これで`1`番目の要素は`1`番目から`n-1`番目の要素の最小値となる。
# * ......
# * `n-2`回目のループ（外側ループ）
#     * 以下の手順が内側ループ
#     * `n-2`番目と`n-1`番目の要素を比べる
#         * 小さい方を左に，大きい方を右に入れ替える
#         * 同じであれば何もしない
#     * `n-3`番目と`n-2`番目の要素を比べる
#         * 小さい方を左に，大きい方を右に入れ替える
#         * 同じであれば何もしない
#     * これで`n-3`番目の要素は`n-3`番目から`n-1`番目の要素の最小値となる。
# * `n-1`回目のループ（外側ループ）
#     * 以下の手順が内側ループ
#     * `n-2`番目と`n-1`番目の要素を比べる
#         * 小さい方を左に，大きい方を右に入れ替える
#         * 同じであれば何もしない
#     * これで`n-2`番目の要素は`n-2`番目から`n-1`番目の要素の最小値となる。
# * 完成！

# In[51]:


def bubble_sort(lst):    #1
    
    n = len(lst)         #2
    
    for i in range(n-1): #3
        
        for j in range(n-1, i, -1): #4
            
            if lst[j-1] > lst[j]:   #5                
                lst[j-1], lst[j] = lst[j], lst[j-1] #6
    
    return lst           #7


# ＜コードの説明＞<br>
# * `#1`: 引数`lst`はイタラブルであるリストを想定している。
# * `#2`: `lst`の要素数を`n`に割り当てる。`n`は`#3`と`#4`で使うことになる。
# * `#3`: 上の説明にある「外側ループ」に対応している。合計で`n-1`回のループ計算をおこない，`lst`の全ての要素インデックスに対応している。
# * `#4`: 上の説明にある「内側ループ」に対応している。`range(n-1, i, -1)`は`i+1`から`n-1`までの番号を逆順に並べている。例えば，`list(range(10, 5, -1))`は`[10,9,8,7,6]`を返す。これは`#5`と`#6`に置いて最後の要素から始まってから`i+1`番目の要素までを順に考える必要があるため。
# * `#5`〜`#6`: `lst[j-1]>lst[j]`とは左の要素が右の要素より大きい場合に`True`を返し，その場合，`#6`では左右の要素を入れ替えている。`#6`は上の説明の２つの要素の入れ替えに対応している。
# * `#7`: 外側ループが終わった後，`lst`を返す。
# 
# コードを実行し，最初の`10`の要素を表示してみよう。

# In[52]:


res = bubble_sort(lst4)
res[:10]


# 最後の`10`の要素を表示してみよう。

# In[53]:


res[990:]


# #### 実行スピード比較

# それぞれの実行スピードを比較してみよう。

# In[54]:


get_ipython().run_line_magic('timeit', 'insertion_sort(lst4)')


# In[55]:


get_ipython().run_line_magic('timeit', 'bubble_sort(lst4)')


# スピードの違いの一つの要因は「値の入れ替え」の回数の差である。
# `insertion_sort()`の場合，`#8`で値の入れ替えがおこなわれており，最大で$n-1$回となる。
# 一方，`bubble_sort()`の値の入れ替えは`#6`でおこなわれており，最大で$n^2/2$回となる。
# $n>2$の場合，$n^2/2>n-1$となるため，実行時間の差に現れていると考えられる。
# 
# 最後に組み込み関数`sorted()`と比較してみよう。

# In[56]:


get_ipython().run_line_magic('timeit', 'sorted(lst4)')


# 平均の単位は`ms`ではなく`µs`となっている。やはり組み込み関数は速い！

# ## 疑似コード

# 前節では簡単なアルゴリズムを`Python`コードとして表し実行したが，その裏にある考え方は他のコンピューター言語でも使うことができる。更に言うと，アルゴリズムを図や言葉で表すことも可能である。[フローチャート](https://www.google.co.jp/search?q=%E3%83%95%E3%83%AD%E3%83%BC%E3%83%81%E3%83%A3%E3%83%BC%E3%83%88%E3%80%80%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0)と呼ばれるのがその一つであり，図を使いアルゴリズムの考えを表現している。そしてもう１つが疑似コードと言われるものであり，自然言語（日本語や英語）で書かれたコードのことである。この２つの手法の利点は，コンピューター言語で発生するエラーを気にせずに，アルゴリズムの考えを理解・整理し，より良い（速い）ものを作り出すことができる土壌となり得ることだろう。以下では疑似コードに基づいてコードの書き方を検討する。
# 
# 上でも説明したが，疑似コードとは，自然言語（日本語や英語）で書かれたコードであるため，`Python`は実行できない箇条書きのような文章となっている。レポートを書く際に，まずアウトラインを考えて書き出す人もいると思うが，それをイメージすれば良いだろう。次の点が重要となる。
# * 明確さ
# * 簡潔さ
# * 細かい詳細は省く
#     * アルゴリズムの核となる部分を捉える
# * 高い可読性
#     * コードを理解できる人ならで誰が読んでも手順が分かるもの
# 
# 一方で，疑似コードの決まった書き方はない。通常は人それぞれ自分のスタイルや好みに合わせて書いているのが実状である（出版のための共通のスタイルがある場合もある）。ここでは次のスタイルとする。
# * `Python`コードと同じインデントを使う。
# * `Python`コード（例えば，`for`や`while`）を使えればそのまま使う。
#     * 疑似コードを英語で書く場合，英語での記述と区別するために大文字を多用するが，日本語とは区別し易いので小文字を使う。
#     
# これら以外は，箇条書きスタイルとしよう。

# ### `FizzBuzz`問題

# まず例として有名な`FizzBuzz`問題を考えよう。
# 
# > 1から100までの数字を表示する。ただし，
# > * 3の倍数は数字の代わりに`Fizz`と表示し，
# > * 5の倍数は数字の代わりに`Buzz`と表示し，
# > * 3と5の倍数は数字の代わりに`FizzBuzz`と表示する。
# 
# 次のコードでは`fizzbuzz`関数として書いている。

# In[57]:


def fizzbuzz():
    
    for i in range(1,100+1):
        
        if i % 3 == 0 and i % 5 == 0:
            print('FizzBuzz')
            
        elif i % 3 == 0:
            print('Fizz')
            
        elif i % 5 == 0:
            print('Buzz')
            
        else:
            print(i)


# ここで`%`は除算の余りを返す演算子である。実行してみよう。

# In[58]:


fizzbuzz()


# これを疑似コードで表してみよう。

# ```
# def フィズバズ（）
# 
#     forループ i <-- 1から100まで
#     
#         if i を3で割ると余り0 and i を5で割ると余り0
#             "FizzBuzz"を表示
#             
#         elif i を3で割ると余り0
#             "Fizz"を表示
#             
#         elif i を5で割ると余り0
#             "Buzz"を表示           
#             
#         else
#             i を表示
# ```

# `Python`コードと疑似コードを比べて，疑似コードがどのようなものかイメージできたのではないだろうか。上にも書いたが，疑似コードの目的はアルゴリズムを表現することであり，`FizzBuzz`の例はその目的を達成している。もちろん，これこそが「正しい」という疑似コードはないので，自分なりに書き替えてみてはどうだろうか。ただ，ここでの目的は質の高い疑似コードを書くことでは**ない**。
# 
# 疑似コードには次の利点がある。
# 
# > プログラミング言語の構文について特に注意を払わずに（エラーを心配せずに），コードの内容を計画・検討することを可能にする。
# 
# この特性を活かして，コードの書き方を検討しようというのがここでの目的である。言い換えると，漠然とした曖昧な疑似コードを**修正する過程**を通して，アルゴリズムを`Python`コードに落とし込むことを考える。５つの例を使うが，疑似コードの修正プロセスがコードを書く上でのヒントになるのではないかと期待している。

# ### リストの合計（`for`ループ）

# ここでの目的：
# > リスト（タプル）の要素の合計を返す関数を作成する。ただし`for`ループを使うこと。

# ---
# ＜Ver. 1＞
# ```
# def 合計(リスト)
# 
#     最初の要素から最後の要素を全て足し合わせる #1
#     
#     その合計を返す
# ```
# * 全体像はイメージできるが，`#1`で要素をどう足し合わせるか不明。要素ごとに何をするかを書き表そう。

# ---
# ＜Ver. 2＞
# ```
# def 合計(リスト)
# 
#     # リストの要素数：N+1
# 
#     0番目の要素に1番目の要素を加える
#     それに2番目の要素を加える。      #1
#     それに3番目の要素を加える。      #1
#     ・・・・・
#     それにN番目の要素を加える。      #1
#     
#     return その合計
# ``` 
# * 具体性が芽生えてきたが，まだコードに落とせない。特に，`#1`にある「それに」をどう扱うかを考えよう。

# ---
# ＜Ver. 3＞
# ```
# def 合計(リスト)
# 
#     # リストの要素数：N+1
# 
#     0番目の要素に1番目の要素を加えて，合計をxとする。 #1
#     xに2番目の要素を加えて，それをxとする。      　 #1
#     xに3番目の要素を加えて，それをxとする。       　#1
#     ・・・・・
#     xにN番目の要素を加えて，それをxとする。      　　#1
#     
#     return x
# ```
# * より具体的になってきたが，`#1`の`x`をどう扱うかを考える必要がある。

# ---
# ＜Ver. 4＞
# ```
# def 合計(リスト)
# 
#     # リストの要素数：N+1
# 
#     x = 0
#     
#     xに0番目の要素の値を足す #1
#     xに1番目の要素の値を足す #1
#     xに2番目の要素の値を足す #1
#     ・・・・・
#     xにN番目の要素の値を足す #1
#     
#     return x
# ```    
# * 骨格ができてきた。`#1`で似た作業がリピートされているのでループを使おう。

# ---
# ＜Ver. 5＞
# ```
# def 合計(リスト)
#     x = 0
#     
#     forループ　i <-- 0からNまで  #1
#         i番目の要素の値をxに足す  #1
#         
#     return x
# ```    
# * `#1`の`i`はリストのインデックス番号になっているが，要素自体で良いのでは？

# ---
# ＜Ver. 6＞
# ```
# def 合計(リスト)
#     x = 0
#     
#     for v <-- リスト
#         要素vをxに足す
#         
#     return x
# ```    
# * ここまで来るとゴールは目の前‼️
# 
# ---

# In[59]:


def sum_for_loop(lst):
    x = 0
    
    for i in lst:
        x += i
    
    return x


# 実行してみよう。

# In[60]:


sum_for_loop([1,2,3]), sum_for_loop(range(0,100))


# ### リストの合計（`while`ループ）

# ここでの目的：
# > リスト（タプル）の要素の合計を返す関数を作成する。ただし`while`ループを使うこと。
# 
# リストの合計（`for`ループ）の＜Ver. 4＞まで同じ。

# ---
# ＜Ver. 4＞
# ```
# def 合計(リスト)
# 
#     # リストの要素数：N+1
# 
#     x = 0
#     
#     xに0番目の要素の値を足す #1
#     xに1番目の要素の値を足す #1
#     xに2番目の要素の値を足す #1
#     ・・・・・
#     xにN番目の要素の値を足す #1
#     
#     return x
# ```    
# * 骨格ができてきた。`#1`で似た作業がリピートされているのでループを使おう。

# ---
# ＜Ver. 5＞
# ```
# def 合計(リスト)
# 
#     x = 0                    #1
#     
#     while 条件                #2
#         i番目の要素の値をxに足す   #3
# 
#     return x
# ```
# * `#2`の条件は何にするのか。
# * 無限ループに入らないように`#1`と`#3`に付け加えることはないか。

# ---
# ＜Ver. 6＞
# ```
# def 合計(リスト)
# 
#     x = 0
#     count = 0                  #1
#     
#     while count < リストの要素数  #2
#         i番目の要素の値をxに足す    #3
#         countを1増やす           #4
# 
#     return x
# ```
# * `#3`の`i`と`#1`，`#2`，`#4`の`count`はどう関係しているのか？同じ？

# ---
# ＜Ver. 7＞
# ```
# def 合計(リスト)
# 
#     x = 0
#     count = 0
#     
#     while count < リストの要素数
#         count番目の要素の値をxに足す
#         countを1増やす
# 
#     return x
# ```
# * ここまで来るとゴールは目の前‼️
# 
# ---

# In[61]:


def sum_while_loop(lst):
    
    x = 0
    count = 0
    
    while count < len(lst):
        x += lst[count]
        count += 1
    
    return x


# 関数を実行しよう。

# In[62]:


sum_while_loop([1,2,3]), sum_while_loop(range(0,100))


# ### コイントス（`for`ループ）

# ここでの目的：
# > `n`回コイントスし，表と裏の回数を表示する関数を作成する。ただし`random.randint()`と`for`ループを使うこと。

# ---
# ＜Ver. 1＞
# ```
# def コイントス(n)
#    
#     0回目のコイントス　→　表・裏  #1
#     1回目のコイントス　→　表・裏  #1
#     2回目のコイントス　→　表・裏  #1
#     ・・・
#     n-1回目のコイントス　→　表・裏   #1
#    
#     表の合計を計算  #2
#     裏の合計を計算  #2
#     
#     表の合計と裏の合計を返す
# ```
# * `#1`で表と裏をどう表す？
# * `#2`の合計の計算はどうする？

# ---
# ＜Ver. 2＞
# ```
# def コイントス(n)
#     
#     # 表：1
#     # 裏：0
#    
#     0回目のコイントス　→　random.randint(0,1)   #1
#     1回目のコイントス　→　random.randint(0,1)   #1
#     2回目のコイントス　→　random.randint(0,1)   #1
#     ・・・
#     n-1回目のコイントス　→　random.randint(0,1) #1
#    
#     表の合計を計算  #2
#     裏の合計を計算  #2
#     
#     表の合計と裏の合計を返す
# ```
# * `#1`は似たコードになるのでループを使おう。
# * `#2`の合計の計算はどうする？

# ---
# ＜Ver. 3＞
# ```
# def コイントス(n)
#     
#     # 表：1
#     # 裏：0
#    
#     for ループ
#         random.randint(0,1)  #1
#    
#     表の合計を計算  #2
#     裏の合計を計算  #2
#     
#     表の合計と裏の合計を返す
# ```
# * `#1`が実行されるたびに`0`又は`1`が出るが，記録されていない。記録する変数を導入する必要がある。
# * その記録を使って`#2`の合計の計算できる。

# ---
# ＜Ver. 4＞
# ```
# def コイントス(n)
#     
#     # 表：1
#     # 裏：0
#    
#     heads = 0
#     tails = 0
#     
#     for ループ                 #1
#         random.randint(0,1)
#         結果が１であれば，headsを１増やす
#         結果が０であれば，tailsを１増やす
#        
#     return heads, tails
# ```
# * `#1`で使うイタラブルは何か？
# * `#1`で使うイタラブル用の変数は何か？

# ---
# ＜Ver. 5＞
# ```
# def コイントス(n)
#     
#     # 表：1
#     # 裏：0
#    
#     heads = 0
#     tails = 0
#     
#     for _ <-- 0からn-1まで            #1
#         random.randint(0,1)
#         結果が１であれば，headsを１増やす  #2
#         結果が０であれば，tailsを１増やす  #2
#        
#     return heads, tails
# ```
# * `#1`で`_`を使っている理由：
#     * `i`や`j`などでも良いが，`for`ループの「本体」で使われていない変数には`_`が使われることがよくある。
# * `#2`を`if`文に書き換える必要がある。

# ---
# ＜Ver. 6＞
# ```
# def コイントス(n)
#     
#     # 表：1
#     # 裏：0
#    
#     heads = 0
#     tails = 0
#     
#     for _ <-- 0からn-1まで
#     
#         random.randint(0,1)の結果をresultに割り当てる
#         
#         if resultが１
#             headsを１増やす
#         
#         else
#             tailsを１増やす
#        
#     return heads, tails
# ```
# * ここまで来ればゴールは目の前‼️
# 
# ---

# In[63]:


def coin_toss_for_loop(n):
    
    heads = 0
    tails = 0
    
    for _ in range(n):
        
        result = random.randint(0,1)
        
        if result == 1:
            heads += 1
            
        else:
            tails += 1
    
    return heads, tails


# 実行しよう

# In[64]:


coin_toss_for_loop(100)


# ### コイントス（`while`ループ）

# ここでの目的：
# > `n`回コイントスし，表と裏の回数を表示する関数を作成する。ただし`random.randint()`と`while`ループを使うこと。
# 
# コイントス（`for`ループ）の＜Ver. 2＞まで同じ。

# ---
# ＜Ver. 2＞
# ```
# def コイントス(n)
#     
#     # 表：1
#     # 裏：0
#    
#     0回目のコイントス　→　random.randint(0,1)   #1
#     1回目のコイントス　→　random.randint(0,1)   #1
#     2回目のコイントス　→　random.randint(0,1)   #1
#     ・・・
#     n-1回目のコイントス　→　random.randint(0,1) #1
#    
#     表の合計を計算  #2
#     裏の合計を計算  #2
#     
#     表の合計と裏の合計を返す
# ```
# * `#1`は似たコードになるのでループを使おう。
# * `#2`の合計の計算はどうする？

# ---
# ＜Ver. 3＞
# ```
# def コイントス(n)
#     
#     # 表：1
#     # 裏：0
#    
#     while ループ
#         random.randint(0,1)  #1
#    
#     表の合計を計算  #2
#     裏の合計を計算  #2
#     
#     表の合計と裏の合計を返す
# ```
# * `#1`で結果を記録する必要がある。
# * その記録を使って`#2`の合計の計算できる。

# ---
# ＜Ver. 4＞
# ```
# def コイントス(n)
#     
#     # 表：1
#     # 裏：0
#     
#     heads = 0
#     tails = 0        #1
#    
#     while 条件　　     #2
#     
#         random.randint(0,1)
#         結果が１であれば，headsを１増やす
#         結果が０であれば，tailsを１増やす  #3
#        
#     return heads, tails
# ```
# * `#2`の条件は何にするのか。
# * 無限ループに入らないように`#1`と`#3`に何を付け加える必要があるか。

# ---
# ＜Ver. 5＞
# ```
# def コイントス(n)
#     
#     heads = 0
#     tails = 0
#     count = 0
# 
#     while count < n
#     
#         random.randint(0,1)
#         結果が１であれば，headsを１増やす  #1
#         結果が０であれば，tailsを１増やす  #1
#         countを1増やす
#        
#     return heads, tails
# ```
# * `#1`を`if`文として書く。

# ---
# ＜Ver. 6＞
# ```
# def コイントス(n)
#     
#     heads = 0
#     tails = 0
#     count = 0
# 
#     while count < n
#     
#         random.randint(0,1)の結果をresultに割り当てる
#         
#         if resultが１
#             headsを１増やす
#         
#         else
#             tailsを１増やす
#             
#         countを1増やす
#        
#     return heads, tails
# ```
# * ここまで来ればゴールは目の前‼️
# 
# ---

# In[65]:


def coin_toss_while_loop(n):
    
    heads = 0
    tails = 0
    count = 0
    
    while count < n:
        
        result = random.randint(0,1)
        
        if result == 1:
            heads += 1
            
        else:
            tails += 1
        
        count += 1
    
    return heads, tails


# コードを実行しよう。

# In[66]:


coin_toss_while_loop(100)


# ### リストの最大値

# ここでの目的：
# > リスト（又はタプル）を引数とし，含まれる要素の中から最大値を返す関数を作成する。

# ---
# ＜Ver. 1＞
# ```
# def 最大値を求める（リスト）:
# 
#     0番目からN番目の要素を比較して最大値を探す  #1
#     
#     最大値を返す
# ```
# * ぼやっとした全体像となっているのは否めない。
# * `#1`の「比較」をどうするかが重要となる。。:

# ---
# ＜Ver. 2＞
# ```
# def 最大値を求める（リスト=l）:
#     
#     # N = リストの要素数
#     
#     <0> l[0]をl[1]〜l[N]と比較し，
#         l[0]が全てに対して大きければ，l[0]が最大値。
#         そうでなければ<1>に進む。
#     <1> l[1]をl[2]〜l[N]と比較し，
#         l[2]が全てに対して大きければ，l[2]が最大値。
#         そうでなければ<2>に進む。
#     <2> l[2]をl[3]〜l[N]と比較し，
#         l[3]が全てに対して大きければ，l[3]が最大値。
#         そうでなければ<3>に進む。
#     ・・・・・
#     <N-1> l[N-1]をl[N]と比較し，
#           l[N-1]大きければ，l[N-1]が最大値。
#           そうでなければl[N]が最大値。
#   
#     最大値を返す
# ```
# 良さそうにも見えるが，問題がある。
# * `<0>`では`N`回の比較をおこなう。
# * `<1>`では`N-1`回の比較をおこなう。
# * `<2>`では`N-2`回の比較をおこなう。
# * ・・・・
# * `<N>`では`1`回の比較をおこなう。
# * 比較する回数の合計は`1+2+3+・・・+N=N(N+1)/2`。比較回数が非常に多い。もっと良い方法があるのでは？

# ---
# ＜Ver. 3＞
# ```
# def 最大値を求める（リスト=l）:
# 
#     # N = リストの要素数
#     
#     l[0]とl[1]を比較し，大きい方を残す    #1
#     l[1]とl[2]を比較し，大きい方を残す    #1
#     l[2]とl[3]を比較し，大きい方を残す    #1
#     ・・・
#     l[N-1]とl[N]を比較し，大きい方を残す  #1
#     
#     最大値を返す
# ```
# * 比較する回数は`N`回で＜Ver. 2＞より少ない。
# * `#1`の「大きい方を残す」はどうする？

# ---
# ＜Ver. 4＞
# ```
# def 最大値を求める（リスト=l）:
# 
#     # N = リストの要素数
# 
#     max_ = -1_000_000        #1
#     
#     l[0]とl[1]を比較し，大きい方をmax_に割り当てる。   #2
#     l[1]とl[2]を比較し，大きい方をmax_に割り当てる。   #2
#     l[2]とl[3]を比較し，大きい方をmax_に割り当てる。   #2
#     ・・・
#     l[N-1]とl[N]を比較し，大きい方をxに割り当てる。 #2
#     
#     return max_
# ```
# * `#2`だけを見ると最大値は求められそう。
# * `#1`では最大値が`-1_000_000`未満の場合をカバーできない。

# ---
# ＜Ver. 5＞
# ```
# def 最大値を求める（リスト=l）:
# 
#     # N = リストの要素数
#     
#     max_ = l[0]
#     
#     max_とl[1]を比較し，大きい方をmax_に割り当てる。  #1
#     max_とl[2]を比較し，大きい方をmax_に割り当てる。  #1
#     max_とl[3]を比較し，大きい方をmax_に割り当てる。  #1
#     ・・・
#     max_とl[N]を比較し，大きい方をmax_に割り当てる。  #1
#     
#     return max_
# ```
# * `#1`は似たようなコードになるのでループを使おう。

# ---
# ＜Ver. 5＞
# ```
# def 最大値を求める（リスト=l）:
# 
#     # N = リストの要素数
#     
#     max_ = l[0]
#     
#     for ループ
#         max_とl[i]を比較し，大きい方をmax_に割り当てる。 #1
#     
#     return max_
# ```
# * `#1`は条件分岐させる必要がある。

# ---
# ＜Ver. 6＞
# ```
# def 最大値を求める（リスト=l）:
# 
#     # N = リストの要素数
#     
#     max_ = l[0]
#     
#     for ループ     #1
#         max_ < l[i]の場合は，l[i]をxに割り当てる。
#         max_ >= l[i]の場合は，pass
#     
#     return max_
# ```
# * `#1`のイタラブルは何にする？
# * `#1`のイタラブル用の変数は何にする？

# ---
# ＜Ver. 7＞
# ```
# def 最大値を求める（リスト=l）:
# 
#     # N = リストの要素数
#     
#     max_ = l[0]
#     
#     for i <-- 0から(lの要素数-1)まで                #1
#         max_ < l[i]の場合は，l[i]をmax_に割り当てる。 #1
#         max_ >= l[i]の場合は，pass                #1
#     
#     return max_
# ```
# * `#1`の`i`はリストのインデックス番号だが，直接要素自体を使う方が`Python`的である。

# ---
# ＜Ver. 8＞
# ```
# def 最大値を求める（リスト=l）:
# 
#     # N = リストの要素数
#     
#     max_ = l[0]
#     
#     for v <-- リスト
#         max_ < vの場合は，vをxに割り当てる。 #1
#         max_ >= vの場合は，pass          #1
#     
#     return max_
# ```
# * `#1`は`if`文に書き換える。

# ---
# ＜Ver. 9＞
# ```
# def 最大値を求める（リスト=l）:
# 
#     max_ = l[0]
#     
#     for v <-- リスト
#     
#         if max_ < v
#             max_にvを割り当てる。
#         else
#             pass
#     
#     return max_
# ```
# * 後は`Python`コードを書くだけ‼️
# 
# ---

# In[67]:


def search_max(l):
    
    max_ = l[0]
    
    for v in l:
        if v > max_:
            max_ = v
        else:         # 省略可
            pass      # 省略可
    
    return max_


# 実行してみよう。

# In[68]:


lst = [random.gauss(0,1) for _ in range(1000)]

search_max(lst)


# ````{note}
# ＜Ver. 2＞をコードで書くと次の様になる。上のコードと比べると実行時間が1000倍近く長くなる。
# ```
# def search_max(l):
#     
#     max_ = l[0]
#     
#     # 最後の要素はカバーしていない
#     for idx, val in enumerate(l[:-1]):
#         
#         temp = max_
#         
# 
#         for k in l[idx+1:]:
#             if val <= k:
#                 continue
#             else:
#                 temp = val
#         
#         if temp > max_:
#             max_ = temp
#     
#     # 最後の要素について
#     if max_ < l[-1]:
#         max_ = l[-1]
# 
#     return max_
# ```
# ````

# ### 最後に

# コードを書くことに慣れてくると，簡単なコードに疑似コードの修正プロセスは必要なくなるだろう。しかし，その段階になればより複雑なコードを書くことになるはずだ。その時には疑似コードが役に立つのではないかと思われる。少し頭をひねるような問題であれば，疑似コードを試してみるのも一案である。
