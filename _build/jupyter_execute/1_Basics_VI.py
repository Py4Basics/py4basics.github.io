#!/usr/bin/env python
# coding: utf-8

# # 図示とシミュレーション

# In[1]:


import random
import math


# ここでの目的は２つある。第１に，`Matplotlib`（「マットプロットリブ」と読む）はプロットのための代表的なパッケージであり，外部パッケージとしては`Matplotlib`のみを使い（`Pandas`や`Numpy`は使わない）データを図示（プロット）する方法を解説する。第２に，統計学の重要な概念をシミュレーションをおこない，データを可視化し理解を深めることである。

# `Matplotlib`は大きなパッケージであり，その中にある`pyplot`モジュールを使うことになる。慣例に沿って`plt`としてインポートする。

# In[2]:


import matplotlib.pyplot as plt


# ## ライン・プロット

# ### 説明

# 次がプロットする際の構文である。
# ```
# plt.plot(＜x軸の値＞,＜y軸の値＞)
# ```

# 実際にプロットするために次の値を設定しよう。

# In[3]:


x = [1,2,3]
y = [10,30,20]


# 引数に`x`と`y`を指定するとプロットできる。

# In[4]:


plt.plot(x, y, marker='o')


# コードに`marker='o'`が追加されているが，「●」を表示するために使っている。このような引数の使い方は後で詳しく説明するので，ここでは気にしないで読み進めて欲しい。
# 
# 「●」のマーカーがある点が`x`と`y`の値の組み合わせとして表示されている。
# * 左下の「●」の座標は`x`と`y`の`0`番目の値である`x=1`と`y=10`となる。
# * 中央上の「●」の座標が`x`と`y`の`1`番目の値である`x=2`と`y=30`となる。
# * 右端の「●」はの座標が`x`と`y`の`2`番目の値である`x=3`と`y=20`となる。
# 
# `plot()`はデフォルトでそれらの点を直線で結んでおり，ライン・プロットと呼ばれる。曲線を描くにはどうすれば良いかと，単に座標の点を増やすことによりスムーズな曲線を表示することが可能となる。言い換えると，短い直線を使うことにより曲線を描画することになる。

# ### 値の生成

# 曲線を描画するためには座標の数を増やす必要がある。ここでは，そのためのコードを考える。

# #### `x`軸の値

# まず`x`軸の複数の値が要素となるリストを作成するが，次の変数を定義しよう。
# * `l`：最小値（lowest value）
#     * リストの要素の最小値
# * `h`：最大値（highest value）
#     * リストの要素の最大値
# * `n`：生成する値の数（整数型，number of values）
#     * リストに含まれる要素の総数
# 
# 例えば，次の値を設定しよう。

# In[5]:


l = 1
h = 2
n = 5


# この値のもとで次の内包表記を使い`1.0`から始まる数字から構成されるリストが作成される。

# In[6]:


lst = [l + x*(h-l)/n for x in range(n+1)]
lst


# `1.0`から始まり昇順で並んでいる。また要素の数は`n+1`となる。

# In[7]:


len(lst) == n+1


# この手法を使い`x`軸の値を生成するが，関数にまとめた方が使い易いので次の`xvalues`関数を作成する。

# In[8]:


def xvalues(l, h, n):
    """引数
        l：最小値（lowest value）
        h：最大値（highest value）
        n：数値の数（整数型，number of values）
    戻り値
        リスト"""
    
    assert isinstance(n, int), "n には整数型を使ってください。"
    
    return [l + x*(h-l)/n for x in range(n+1)]


# 以前も説明したが，引数などを確認したい場合は次のコードで調べることができるので覚えておこう。

# In[9]:


help(xvalues)


# この`xvalues`関数を使い，`x`の値を生成しよう。

# In[10]:


x = xvalues(-1, 1, 5)
x


# #### `y`軸の値
# 

# `y`軸の値は，描きたい関数に依存している。例えば，次の２次関数をプロットしたいとしよう。
# 
# $$y=x^2$$
# 
# まず最初にこの関数を捉える`Python`の関数を作成する。

# In[11]:


def quadratic(x):
    return x**2


# 次に，`x`の値を使い内包表記で`y`の値から構成されるリストを作成する。

# In[12]:


y = [quadratic(i) for i in x]
y


# ### 曲線のプロット

# 上で作成した`x`と`y`を使いプロットしよう。

# In[13]:


plt.plot(x, y, marker='o')


# 座標の数が少ないのでスムーズな曲線には見えない。もっと座標を増やしてみよう。

# In[14]:


x = xvalues(-1, 1, 200)
y = [quadratic(i) for i in x]

plt.plot(x, y)


# $y=x^2$の図らしく見える。
# 
# ````{hint}
# 上の２つの図の上に文字が表示されているが，表示したくない場合は最後に`;`を加えるか，次の行に`pass`もしくは`plt.show()`と書くと表示されなくなる。
# ````

# ### 重ねてプロット

# ２つの`y`の値を生成しよう。

# In[15]:


y0 = [quadratic(i) for i in x]
y1 = [-quadratic(i) for i in x]


# `y0`は`y`と同じであり，`y1`は単にマイナスの符号ついた関数の値である。この２つの関数を重ねてプロットしたいとしよう。コードは簡単で同じ`plt.plot()`をリピートするだけである。

# In[16]:


plt.plot(x, y0)
plt.plot(x, y1)
pass


# ### `plot()`の基本的な引数

# `plot()`に引数を使うことによりデータの表示方法を指定できる。詳しくは[このリンク](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html)を参照することにして，ここでは基本的な引数だけを紹介する。
# * `linestyle`：線のスタイル（リストにして列の順番で指定する;`-`，`--`，`-.`，`:`などがある）
# * `linewidth` or `lw`：線の幅
# * `color` or `c`：色（[参照サイト](https://matplotlib.org/stable/gallery/color/named_colors.html)）
#     * `r`又は`red`は赤
#     * `k`又は`black`は黒
#     * `g`又は`green`はグリーン
# * `marker`：観測値のマーカー（`o`，`.`，`>`，`^`などがある; [参照サイト](https://matplotlib.org/stable/api/markers_api.html)）
# * `markersize`：マーカーの大きさ
# * `label`：以下で説明する`ax.legend()`がある場合に有効となる

# In[17]:


plt.plot([1,2,3], [10,30,25],
         linestyle=':',
         linewidth=2,
         color='r',
         marker='o',
         markersize=10)
plt.plot([1,2,3], [30,10,15],
         linestyle='-',
         linewidth=2,
         color='k',
         marker='^',
         markersize=10)
pass


# 引数をいちいち書くのが面倒な場合、次の３つを簡略して一緒に指定できる。
# * `linestyle`
# * `color`
# * `marker`
# 
# 例えば、
# * `linestyle=':'`
# * `color='red'`
# * `marker='o'`
# 
# の場合、`:ro`と書くことができる。

# In[18]:


plt.plot([1,2,3], [10,30,25], ':ro')
pass


# （注意点）
# * `:ro`は文字列
# * `:`，`r`，`o`の順番を変えても良い。
# * `:`や`:o`のように１つもしくは２つだけを指定しても良い。
# * `:ro`は`=`を使う引数の前に置く。
# 
# 詳細は[参考サイト（英語）](https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.plot.html)を参照。

# ### その他の「飾り付け」

# 次の５つは`plt.plot()`の下に付け加えることによって表示できる。
# * `plt.title()`：タイトルを設定する。
#     * 文字列で指定し、大きさは引数`size`で指定する。
# * `plt.xlabel()`：横軸ラベル
#     * 文字列で指定し、大きさは引数`size`で指定する。
# * `plt.ylabel()`：縦軸ラベル
#     * 文字列で指定し、大きさは引数`size`で指定する。
# * `plt.legend()`：凡例を表示する。
#     * `plot()`の引数`label`を使って表示する文字列を指定する。
#     * `fontsize`：フォントの大きさを指定する。
# * `plt.grid()`：グリッド線が表示される。

# In[19]:


plt.plot([1,2,3], [10,30,25], ':ro', label='This is a legend')
plt.title('This is a Title', size=30)
plt.xlabel('Label for x', size=20)
plt.ylabel('Label for y', size=20)
plt.legend(fontsize=20)
plt.grid()
pass


# ````{note}
# このままで日本語を表示できない。一番簡単な方法は外部パッケージの`japanize_matplotlib`を使うことだろう。まずコンピューターにインストールする必要がある。Google Colaboratoryであれば，**毎回**次のコードを最初に実行してインストールする必要がある。
# ```
# !pip install japanize-matplotlib
# ```
# その後，次を実行すれば他の設定なしに日本語が使える。
# ```
# import japaneze_matplotlib
# ```
# ````

# ## ヒストグラム

# 基本的には次の構文となる。
# ```
# plt.hist(＜データ＞)
# ```
# 
# まず標準正規分布からランダム変数を10,000個抽出して変数`z0`に割り当てよう。

# In[20]:


z0 = [random.gauss(0,1) for _ in range(10_000)]


# このデータのヒストグラムを表示してみよう。

# In[21]:


plt.hist(z0)
pass


# **＜基本的な引数＞**
# 
# 様々な引数があり図に「飾り付け」をすることができる。詳しくは[このリンク](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.hist.html)を参照することにして，ここでは基本的な引数だけを紹介する。
# * `bins`：柱の数
#     * 整数型を使えば文字通りの柱の数となる。
#     * 区間の値をリストとして設定することができる。例えば，`0`と`1`を等区間に柱を２つ設定する場合は`[0, 0.5, 1]`となる。
# * `linewidth`又は`lw`：柱の間隔（デフォルトは`1`）
# * `color`：色（リストにして列の順番で指定する; [参照サイト](https://matplotlib.org/3.1.0/gallery/color/named_colors.html)）
#     * `r`又は`red`：赤
#     * `k`又は`black`：黒
#     * `g`又は`green`：グリーン
# * `edgecolor`又は`ec`：柱の境界線の色
# * `alpha`：透明度（`0`から`1.0`; デフォルトは`1`）
# * `density`：縦軸を相対度数にする（デフォルトは`False`）
# * `label`：凡例の表現を指定
#     * `ax.legend()`が設定されている場合のみ有効
#     
# 上のヒストグラムに引数をしてしてみよう。

# In[22]:


plt.hist(z0,
         bins = 30,
         lw=2,
         color='green',
         ec='white',
#          alpha=0.5,
#          label='values of z'
         density=True)

pass


# 次に複数のデータを重ねてプロットする場合を考えよう。方法は簡単で，ライン・プロットと同じように`plt.hist()`を続けてコードを書くだけである。まず平均`4`標準偏差`2`の正規分布からのランダム変数を用意しよう。

# In[23]:


z1 = [random.gauss(5,2) for _ in range(10_000)]


# `z0`と`z1`のヒストグラムを重ねて表示しよう。

# In[24]:


plt.hist(z0,
         bins = 30,
         color='red',
         ec='white',
         alpha=0.5)
plt.hist(z1,
         bins = 30,
         color='black',
         ec='white',
         alpha=0.5)
pass


# 濃い赤の部分が重なっている部分となる。
# 
# その他の「飾り付け」（タイトルなど）はライン・プロットと同じとなる。

# In[25]:


plt.hist(z0,
         bins = 30,
         color='red',
         ec='white',
         alpha=0.5,
         label='z0')
plt.hist(z1,
         bins = 30,
         color='black',
         ec='white',
         alpha=0.5,
         label='z1')
plt.title('This is a Title', size=30)
plt.xlabel('Label for x', size=20)
plt.ylabel('Label for y', size=20)
plt.legend(fontsize=20)
plt.grid()

pass


# ##  中心極限定理

# ### 中心極限定理とは

# 母集団（大きさが無限）のパラメータを次の様に表記しよう。
# * $\mu$：平均
# * $\sigma$：標準偏差
# 
# この母集団から標本$X_1,X_2\cdots X_n$を抽出し（$n$は標本の大きさ），その平均を$\overline{X}$とする。
# 
# $$
# \overline{X}=\frac{X_1+X_2+\cdots+X_n}{n}
# $$
# 
# 標本を取るごとに$X_i$，$i=1,2...n$の値は異なるため，$\overline{X}$自体もランダム変数となる。更に，標準化した平均を次の様に定義しよう。
# 
# $$
# Z_n = \frac{\overline{X}-\mu}{\sigma/\sqrt{n}}
# $$ (eq:1-6-Zn)
# 
# ここで$Z_n$は平均`0`，分散`1`となるランダム変数である。これにより，$Z_n$の**分布型は不明**だが，少なくとも平均と分散の２つのパラメータに関する限り標準正規分布と共通点がある。
# 
# **＜中心極限定理（Central Limit Theorem)＞**<br>
# > 母集団の分布がどのようなものであれ（連続型，離散型），$\mu$と$\sigma$が有限である限り，$n$が大きくなると$Z_n$の分布は標準正規分布$N(0,1)$に近づいていく。

# この驚くべき結果は統計学の金字塔である。ではどこが金字塔なのだろうか。データ分析のためには標本を集める必要がある。例えば，大学生の１日の授業以外の勉強時間（単位は分）を考えてみよう。マイナス時間や24時間以上はあり得ないため，母集団の分布は正規分布ではないことは明らかである。標本の中には驚くほど勉強している人もいれば，アルバイトなどに追われ`0`分の学生も含まれるかも知れない。もしかすると，分布には複数のピークがあるかもしれない（例えば，`0`と`70`分）。いずれにしろ，母集団の分布は未知であるため，仮説検定は不可能のように感じられる。しかし中心極限定理は，超えることはできないように見える壁をいとも簡単に飛び越えさせてくれる。ランダム標本を集め，標本の大きさが十分に大きければ，標本平均は正規分布に従う（近似される）ため仮説検定が可能になるのだ。
# 
# ここでの目的は，シミュレーションを使って中心極限定理を視覚的に理解・確認することである。コイントスの例を使い，次のステップで進める。
# 1. `c`個のコインを同時に投げることを考え，その標準化平均を計算する。
# 1. 標準化平均を計算するための関数を作成する。
# 1. コイントスのシミュレーションをおこない，そのヒストグラムをプロットする。
# 1. コイントスのヒストグラムと標準正規分布を重ねて表示し，標本の大きさ（コインの数`c`）が大きくなると前者は後者に近づいていく事を視覚的に確かめる。

# ### コイントスのシミュレーション

# コインの表を`1`，裏を`0`とするコイントスを考えよう。`1`と`0`はそれぞれ確率$p=0.5$で発生するベルヌーイ分布に従うと仮定する。従って，以下が成り立つ。
# * 平均：$p=0.5$
# * 分散：$p(1-p)=0.5^2$
# * 標準偏差：$\sqrt{p(1-p)}=0.5$
# 
# この様なランダム変数は既出の次の関数で表すことができる。

# In[26]:


random.randint(0,1)


# 次に，`20`個のコインを同時に投げる場合を考えよう（`1`個のコインを`20`回投げても同じ）。この場合の`20`が標本の大きさであり，変数`c`（coinsの頭文字）に割り当てよう。

# In[27]:


c = 20


# 標本の大きさが`c`の場合の結果は，次の内包表記を使うと簡単に生成することができる。

# In[28]:


tosses = [random.randint(0,1) for _ in range(c)]
tosses


# `1`（表）が何回発生したかを数えてみよう。

# In[29]:


heads = tosses.count(1)
heads


# ここで，`count()`はリストのメソッドであり，引数の値（ここでは`1`）の数を返す。この結果を利用すると平均は次のように計算できる。

# In[30]:


tosses.count(1) / c


# 更に，上の式[](eq:1-6-Zn)に従って，この平均を標準化した値を計算すると次の様になる。

# In[31]:


(heads/c - 0.5) / ( math.sqrt(0.5*0.5)/math.sqrt(c) )


# ### 関数化

# 上では一回だけのシミュレーションをおこなった。以下では任意の回数のシミュレーションをおこなうために，上のコードを関数にまとめることにする。２つの関数に分けてコードを書くことにする。
# 
# まず同時に投げるコインの数とその結果のコインの表の数を所与として，平均が標準化された値を計算する関数を作成する。

# In[32]:


def standardize(c, h):
    """
    引数：
        c：同時にトスしするコインの数
        h：コインの表の数
    戻り値：
        コインの表の平均を標準化した値"""
    
    return (h/c - 0.5) / ( math.sqrt(0.5*0.5)/math.sqrt(c) )


# この関数は`c`と`h`が与えられば，標準化平均を返す。上の数値を使って，この関数を実行してみよう。

# In[33]:


standardize(c, heads)


# 同じ値を返していることが確認できる。
# 
# 次に，同時にトスするコインの数は所与とするが，関数の中でランダム変数として`1`の数が決まり，その標準化平均を返す関数を作成しよう。

# In[34]:


def mean_standardized(c):
    """
    引数：
        c：同時にトスするコインの数
    戻り値：
        コインの表の平均を標準化した値"""
    
    tosses = [random.randint(0,1) for _ in range(c)]
    heads = tosses.count(1)
    
    return standardize(c, heads)


# `c=20`で実行しよう。

# In[35]:


mean_standardized(20)


# この値は`20`個のコインを同時に投げた結果の平均を標準化した値である。`mean_standardized()`関数を実行するたびに，コインが投げられ標本が集められるので，標準化平均の値は上の結果とは異なる。実行するたびに異なる値を取るランダム変数を返すことになる。
# 
# 次に，`20`個の同時コイントスを`10`回おこない，毎回標準化平均を計算するとしよう。このシミュレーションの結果は次の内包表記で生成することができる。

# In[36]:


[mean_standardized(20) for _ in range(30)]


# ランダム変数なので，実行する度に異なる値が並ぶ。また同じ値が複数回発生していることも確認できるだろう。

# ### ヒストグラム

# #### 階級区間

# ここでは上の説明に従って，コインの数`c`を変化させシミュレーションをおこない，その結果をヒストグラムとして表示するのが目的である。ここで注意する点は，階級の区間によって見え方違ってくるという点だ。以下では，中心極限定理を視覚的に確認できるように次の方法で区間を設定する。
# 
# 次の表の１列目は`c`の値（同時にトスするコインの数）を表しており，２列目はコインの表が発生しうる数をまとめている。例えば，`c=1`の場合，`{[裏],[表]}`の可能性しかないため`{0,1}`となっている。`c=2`の場合，`{[裏,裏],[表,裏],[裏,表],[表,表]}`の可能性があるため`{0,1,2}`となっている。
# 
# | `c` | 発生しうるコインの表の数 | 標準化した値 |
# | --- | ------------------ | ----------- |
# | `1` | `{0,1}`     | `{-1.0,1.0}`  |
# | `2` | `{0,1,2}`   | `{-1.41,0,1.41}` |
# | `3` | `{0,1,2,3}` | `{-1.73,-0.58,0.58,1.73}` |
# | `4` | `{0,1,2,3,4}` | `{-2.00,-1.00,0,1.00,2.00}` |

# ３列目は，`standardize()`関数を使い２列目の値を標準化した値が並んでいる。例えば，`c=2`の場合は次のようになる。

# In[37]:


for i in range(2+1):
    print(f'{i}　→　{standardize(c=2, h=i):.2f}')


# これからプロットするヒストグラムには３列目の値が横軸に並ぶことになる。

# `c=1`を考えよう。この場合，２列目に`0`と`1`の２つの値があるため，ヒストグラムには２本の柱が必要となる。３列目の値`-1.0`と`1.0`を使うと１区間しかないため柱は１にしかならない。一方，`c=2`の３列目には数値が３つあり，２区間が確保できる。更に，`c=1`の３列目の値は`c=2`の３列目の値からなる２区間の間に入ることになる。`c=2`以上の階級区間についても同様のことが言える。この特徴を使って次の様にしよう。
# * `c=1`の階級区間には`c=2`の３列目の値を使う
# * `c=2`の階級区間には`c=3`の３列目の値を使う
# * `c=3`の階級区間には`c=4`の３列目の値を使う
# * `...`
# 
# ヒストグラムをプロットする際には，`c`を所与として階級区間を計算する必要があるが，次の内包表記で可能となる。
# ```
# [standardize(c+1, h) for h in range(c+1+1)]
# ```

# 例えば，`c=1`の階級区間を計算してみよう。

# In[38]:


[standardize(1+1, h) for h in range(1+1+1)]


# ２つの階級区間が作られている。

# #### ヒストグラム

# では実際にヒストグラムをプロットしてみよう。例として次の数値を使う。
# * 同時に投げるコインの数（標本の大きさ）：`c = 1`
# * シミュレーションの回数：`n = 10`

# In[39]:


# パラメータの設定
c = 1
n = 10

# コイントスのシミュレーション
sim = [mean_standardized(c) for _ in range(n)]

# ヒストグラム
plt.hist(sim,
         bins=[standardize(c+1, h) for h in range(c+1+1)],
         ec='white',
         density=True)
plt.show()


# ＜注意点＞
# * ヒストグラムの柱の幅は階級区間を示すが，シミュレーションの値がそれぞれの区間内で散らばっているのでは**ない**。左の柱にある値は`-1.0`のみであり，右の柱にある値は`1.0`のみである。柱ではなく`-1.0`と`1.0`に細い縦線だけを表示する方が結果と近い図になる（下では，そのような図を表示している）。

# ````{note}
# 棒グラフとして表示したい場合は`plt.bar()`を使うことができる。
# ```
# c = 1
# n = 10
# sim = [mean_standardized(c) for _ in range(n)]
# sim_unique = sorted(list(set(sim)))
# count_on_y_axis = [sim.count(i) for i in sim_unique]
# xlabel = [str(i) for i in sorted(list(set(sim)))]
# plt.bar(xlabel, count_on_y_axis)
# plt.show()
# ```
# ````

# #### 関数化

# ヒストグラムを描くことができたが，`c`と`n`の異なる値ごとに上のコードをコピペして使うの面倒なので，関数としてまとめよう。

# In[40]:


def draw_hist(c,n):
    
    sim = [mean_standardized(c) for _ in range(n)]

    plt.hist(sim,
             bins=[standardize(c+1, h) for h in range(c+1+1)],
             ec='white',
             density=True)
    
    plt.title(f'Coins: c={c}, Repetition: n={n}', size=20) #1
    
    print(f'コイントスの唯一の値の数（x軸）：{len(set(sim))}') #2
    
    return plt.show()  #3


# ＜コードの説明＞
# * `#1`：タイトルを追加している。
# * `#2`：`sim`はコイントスのシミュレーションの結果だが，`set()`関数を使うと唯一の値を返し，`len()`で唯一の数を返している。
# * `#3`：戻り値を設定するが，ここでは`plt.show()`を返している。`plt.show()`とは，文字通りこの行の「上で作成された図を表示する」ことを意味している。即ち，「図の表示」を返している。
# 
# 次の値でヒストグラムを表示してみよう。
# * 同時に投げるコインの数：`c = 1`
# * シミュレーションの回数：`n = 10`

# In[41]:


draw_hist(c, 20)


# 上述のように，柱の階級区間内にシミュレーションの値が散らばっているのではなく，この場合は`-1.0`と`1.0`の`2`つの値に全てのデータが集中している。図の上に表示されている数字`2`はその数を示している。

# ### シミュレーション

# ここでの目的は中心極限定理をヒストグラムを使って確認することである。そのためには，上で作成したコイントスのヒストグラムを標準正規分布のヒストグラムと比べる必要がある。まず標準正規分布から`10_000`個のランダム変数を抽出し，その結果をヒストグラムとしてプロットしてみよう。

# In[42]:


val_normal = [random.normalvariate(0, 1) for _ in range(10_000)]
plt.hist(val_normal, 
         bins=100, 
         ec='white', 
         density=True)
plt.show()


# ランダム変数なのでギザギザになっているが，典型的なベル型の分布となっている。引数`bins=100`はベル型ははっきりと分かる様であれば，どの値でもよい。
# 
# 次に，コイントスのヒストグラムを標準正規分布のヒストグラムに重ねて表示しよう。同時に投げるコインの数`c`（標本の大きさ）を増やすとコイントスのヒストグラムは標準正規分布のヒストグラムに近づいていく事を視覚的に確認するためである。`c`に様々な値を割り当ててプロットするために関数を作成しよう。次の関数は，`draw_hist`関数のコードと標準正規分布のヒストグラムのコードを使って，少しだけ修正を加えてものである。

# In[43]:


def clt(c, n=10_000):  #1

    
    # 標準正規分布のヒストグラム ---------------------------------
    val_normal = [random.normalvariate(0, 1) for _ in range(10_000)]
    plt.hist(val_normal,
             bins=100,
#              ec='white',
             density=True,
             label='Standard Normal') #2

    # コイントスのシミュレーションとヒストグラム ---------------------
    sim = [mean_standardized(c) for _ in range(n)]

    plt.hist(sim,
             bins=[standardize(c+1, h) for h in range(c+1+1)],
             ec='white',
             density=True,
             label='Tossing Coins',   #3
             alpha=0.5)               #4
    

    # タイトル，凡例，x軸の範囲 ---------------------------------
    plt.title(f'Coins: c={c}, Repetition: n={n}', size=20)
    plt.legend()                      #5
    plt.xlim([-4,4])                  #6
    
    print(f'コイントスの唯一の値の数（x軸）：{len(set(sim))}') #7
    
    return plt.show()


# ＜コードの説明＞<br>
# 基本的に上で使ったコードと大きく違わないが，新しく導入した箇所を説明しよう。
# * `#1`：`n`にデフォルトの値`10_000`を設定。関数名の`clt`はCentral Limit Theoremの頭文字。
# * `#2`：凡例のラベルを設定
# * `#3`：凡例のラベルを設定
# * `#4`：透過度の設定
# * `#5`：凡例の表示をオンにする
# * `#6`：`x`軸の表示範囲を`-4`から`4`までに設定する。この設定がないと，`c`の値が増えるにつれて`x`軸も伸びていき，ヒストグラムが小さくなる。それを防ぐために追加している。また標準正規分布のランダム変数は殆どのこの範囲内に収まることになる。

# In[44]:


# この関数は柱ではなく標準化平均に赤の縦線を表示する。

def clt_line(c, n=10_000):

    
    # 標準正規分布のヒストグラム ---------------------------------
    val_normal = [random.normalvariate(0, 1) for _ in range(10_000)]
    plt.hist(val_normal,
             bins=100,
             density=True,
             label='Standard Normal')


    # コイントスのシミュレーション --------------------------------
    sim = [mean_standardized(c) for _ in range(n)]

    counts, bins, ignored = plt.hist(sim,
             bins=[standardize(c, h) for h in range(c+1+1)],
             ec='white',
             density=True,
             alpha=0)
    # コイントスの縦線 -----------------------------------------
    k = 0.5  
    
    for b, cc in zip(bins, counts):
        plt.axvline(b, 0, cc/k, color='red')

    # タイトル，凡例，x軸の範囲 ----------------------------------
    plt.title(f'Coins: c={c}, Repetition: n={n}', size=20)
    plt.legend(['Standard Normal','Tossing Coins'])
    plt.xlim([-4,4])
    plt.ylim([0,k])

    print(f'コイントスの唯一の値の数（x軸）：{len(set(sim))}')
    
    return plt.show()


# これでシミュレーションの準備は整った。`c`の数値を変えてプロットしてみよう。

# In[45]:


clt(1)


# `c=1`のヒストグラムは標準正規分布と大きく掛け離れている。更に，コイントスのシミュレーションの値は，`-1`と`1`の`2`つの値に集中している事を思い出そう。（直ぐ下に Click to show とあるが，それをクリックするとシミュレーション結果が`-1`と`1`に集中している図が表示されるので参考にしよう。）

# In[46]:


clt_line(1)


# In[47]:


clt(2)


# `c=2`のヒストグラムは左右対称に見えるが，これは`n`が大きいためである。シミュレーションの`x`軸の値は`3`つである。標準正規分布とは大きく異なる。

# In[48]:


clt_line(2)


# In[49]:


clt(12)


# 標準正規分布に近づいていることが視覚的に分かる。しかし，シミュレーションの`x`軸の値は`13`である。

# In[50]:


clt_line(12)


# In[51]:


clt(64)


# 標準正規分布に更に近づいている。シミュレーションの`x`軸の値は`29`である。

# In[52]:


clt_line(64)


# In[53]:


clt(1000)


# 標準正規分布の近似としては十分な重なり具合と言っていいだろう。

# In[54]:


clt_line(1000)

