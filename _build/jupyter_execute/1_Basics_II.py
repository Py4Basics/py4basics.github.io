#!/usr/bin/env python
# coding: utf-8

# # データの操作

# ## 基本データ型の変換

# 次の３つの基本データ型を考えよう。
# * 整数型
# * 不動小数点型
# * 文字列型
# * ブール型

# ```{margin}
# <div name="html-admonition">
# Do you want to read in a differnt language? Start
# <input type="button" onclick="location.href='https://translate.google.com/translate?hl=&sl=ja&tl=en&u='+window.location;" value="Google" style="color:#ffffff;background-color:#008080;" onmouseover="this.style.background='#99ccff'" onmouseout="this.style.background='#008080'"/><input type="button" onclick="location.href='https://translate.google.com/translate?hl=&sl=ja&tl=en&u='+window.location;" value="translation" style="color:#ffffff;background-color:#008080;" onmouseover="this.style.background='#99ccff'" onmouseout="this.style.background='#008080'"/>
# in English or the language of your choice.
# </div>
# ```

# ここでは，それぞれのデータ型を他のデータ系に変換する次の関数を紹介する。
# * `int()`：整数型への変換
# * `float()`：不動小数点型への変換
# * `str()`：文字列型への変換
# * `bool()`：ブール型への変換（真偽値の確認）

# ### 整数型・不動小数点型　→　不動小数点型・整数型

# In[1]:


f0 = 10.0
i0 = 10


# `f0`を整数型へ，`i1`を不動小数点型に変換してみよう。

# In[2]:


int(f0), type( int(f0) )


# In[3]:


float(i0), type( float(i0) )


# ### 文字列型　→　整数型・不動小数点型

# 次に文字列を考えよう。

# In[4]:


s0 = '10'


# `int()`を使うと整数に変換できる。また`float()`関数を適用すると不動小数点型に変換できる。

# In[5]:


int(s0), type( int(s0) )


# In[6]:


float(s0), type( type(s0) )


# これを利用して次の演算が可能となる。

# In[7]:


2 + int(s0), 2 + float(s0)


# 次に以下の文字列を考えよう。

# In[8]:


s1 = '10.0'


# まず`float()`を使って不動小数点型に変換してみよう。

# In[9]:


float(s1), type( float(s1) )


# これにより算術演算が可能となる。

# In[10]:


float(s1) // 3


# 一方で`int()`を使うとエラーが発生する。

# In[11]:


int(s1)


# 直感的には，`s1`の小数点以下の`0`があるからである。この場合，整数型に変換するには次の２ステップ必要となる。
# ```
# s1　→　不動小数点型　→　整数型
# ```

# In[12]:


int( float(s1) )


# In[13]:


int( float(s1) ) ** 5


# ### 整数型・不動小数点型　→　文字列型

# 文字列型への変換は簡単で，元の値をそのままクォテーション`''`に入れて返すことになる。

# In[14]:


str(f0), str(i0)


# ### 整数型・不動小数点型・文字列型　→　ブール型

# この変換は既出の`bool()`を使い，対象となるデータのブール値（真偽値）の確認となる。即ち，対象となるオブジェクトが「空・無」かどうかを確かめるの使われる。

# In[15]:


bool(100)


# In[16]:


bool(0)


# In[17]:


bool('神戸大学'), bool('')


# ## コンテナデータ型の操作

# ここではコンテナデータ型の次の操作について説明する。
# * 要素の抽出（アクセス）
# * 要素の入れ替え
# * 要素の削除
# * 他のデータ型からリストへの変換
# * 基本的なメソッド

# ### リスト

# #### １つの要素の抽出

# 要素のインデックス（位置）を考える場合，次の図のように左から`0`，`1`，`2`...，右からは`-1`，`-2`，`-3`と数える。
# ```
#    0   1   2   3   4   5  （左から数える） 
#  +---+---+---+---+---+---+
#  | P | y | t | h | o | n |
#  +---+---+---+---+---+---+
#   -6  -5  -4  -3  -2  -1　（右から数える）
# ```
# 例えば，次のリストを考えよう。

# In[18]:


my_list = ['A', 'B', 'C', 'D', 'E', 'F']


# `'A'`は０番目，`'B'`１番目，`'C'`は２番目と数える。`A`を抽出したい場合は`[]`を使い`A`のインデックス番号`0`を指定する。

# In[19]:


my_list[0]


# `E`にアクセスしたい場合は，インデックス番号は`4`なので次のようになる。

# In[20]:


my_list[4]


# または右から数えたインデックス番号`-2`を使っても同じ結果となる。

# In[21]:


my_list[-2]


# #### 複数要素の抽出（その１）

# 次に複数の連続する要素を抽出したいとしよう。この場合はスライシングと呼ばれ，`:`（コロン）を使う。`:`の左右にインデックス番号を置き要素を選択するが，次のルールに従う。
# ```
# [＜start＞:＜end＞]
# ```
# * `start`：最初のインデックス
# * `end`：最後の**次の**インデックス
# 
# 即ち，`:`の右側にあるインデックスの要素は抽出されない。例えば，`my_list`の１番目から３番目の要素を抽出したい場合は`1:4`となる。

# In[22]:


my_list[1:4]


# 次のように書くとより直感的になるのではないだろうか。

# In[23]:


my_list[1:3+1]


# 次のルールも覚えておこう。
# * `:`の左側の番号を省略すると「`0`番目から」と解釈される。
# * `:`右側を省略すると「最後まで」と解釈される。
# 
# 次のコードは最初からスライスしている。

# In[24]:


my_list[:3+1]


# 最後までスライスする場合は次のコードとなる。

# In[25]:


my_list[3:]


# では`:`の左右の番号を省略するとどうなるのだろう。「最初から最後まで」，即ち，全てとなり，リストのコピーを作成することと同じである。

# In[26]:


your_list = my_list[:]
your_list


# ````{note}
# `my_list`の`A`，`C`，`E`のように連続していない要素を同時に抽出したい場合はどうすれば良いだろうか。残念ながら，簡単な方法は用意されていない。しかし１つの方法として次のコードで要素のインデックス番号を指定してアクセスすることが可能である。
# ```
# my_idx = [0,2,4]
# [my_list[i] for i in my_idx]
# ```
# １行目は`A`，`C`，`E`のインデックス番号のリストであり，２行目は後に説明する内包表記を使っている。
# ````

# #### 複数要素の抽出（その２）

# 上の説明でのスライシングのインデックス番号は，`1,2,3,4`の様に**増分**は`1`となっている。実は，この増分も次のように設定することができる。
# ```
# [＜start＞:＜end＞|＜step＞]
# ```
# * `start`：最初のインデックス
# * `end`：最後の**次の**インデックス
# * `step`：増分（デフォルトは`1`）
# 
# `step`のデフォルトは`1`なので，設定しなければ増分は`1`となり，上で説明したスライシングとなる。ここでは`step`を指定した場合について触れる。次の例を考えよう。

# In[27]:


lst = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]


# `step`を`2`にすると，インデックス番号が一つおきとなり偶数だけが抽出される。

# In[28]:


lst[::2]


# ここでは`start`と`end`は指定されていないので，全てのインデックス番号が抽出の対象となっている。もちろん`step`を`3`にすると２つおきのインデックス番号の要素が抽出される。

# In[29]:


lst[::3]


# また`step`に負の整数を使うと，要素を逆に並べて結果を返すことになる。次の例は，全ての要素を逆に並べている。

# In[30]:


lst[::-1]


# もちろん`-2`にすると，逆順で一つおきの要素が抽出される。

# In[31]:


lst[::-2]


# #### ２次元リストの要素抽出

# 次の例は入れ子のケースである。

# In[32]:


my_list2 = ['A', ['B', 'C'], ['D', 'E', 'F', 'G', 'H']]


# この場合でも考え方は変わらない。例えば，`['B','C']`を抽出したいとしよう。`['B','C']`は`1`番目の要素として入っているので次のコードでアクセスできる。

# In[33]:


element1 = my_list2[1]
element1


# 更に，`element1`の`B`を抽出したいとしよう。その場合も同じ考えで次のコードとなる。

# In[34]:


element1[0]


# また別々に書いたコードを続けて書いても同じ結果となる。

# In[35]:


my_list[1][0]


# もちろんスライシングも使える。`D`，`E`，`F`を抽出したい場合は次のコードとなる。

# In[36]:


my_list2[-1][:2+1]


# #### 要素の入れ替え

# 要素の入れ替え方法を説明するために，次のリスト`lst0`を作成しよう。

# In[37]:


lst0 = [0, 1, 2 ,3, 4, 5]
lst0


# `0`番目の要素は`0`だが，これを文字列`'Kobe'`に入れ替えてみよう。方法は簡単で，入れ替えたい要素を選び`=`の左辺に置き，右辺には新しい要素を配置し実行するだけである。次のコードとなる。

# In[38]:


lst0[0] = 'Kobe'
lst0


# 右辺から読めば理解できる。「`Kobe`を`lst0[1]`に割り当てる」となり，これで「入れ替え」となる。この例の右辺は文字列だが，他のデータ型でも可能である。例えば，

# In[39]:


lst0[1] = {'a':100}
lst0


# スライシングを使い要素入れ替えも可能である。

# In[40]:


lst0[-2:] = (40, 60)
lst0


# この場合，左辺の要素数と右辺の要素数が同じになる必要がある。また右辺に辞書を置くとキーの値が割り当てられることになる。試してみよう。

# In[41]:


lst0[-2:] = {'A':40, 'B':60}
lst0


# #### 要素の削除

# 要素を削除するには色々な方法が用意されているが，最も簡単なのは`del`（deleteの略）を使うことだろう。`del`の後に削除したい要素を書き実行するだけである。例えば，

# In[42]:


del lst0[0]
lst0


# `Kobe`が削除されている。次の例はスライシングを使い`A`と`B`を削除している。

# In[43]:


del lst0[-2:]
lst0


# #### 他のコンテナデータ型からリストへの変換

# * 関数`list()`を使う。
# 
# 次のタプルを考えよう。

# In[44]:


tpl = (1, 3.14, 'A')
tpl


# `list()`を使うとリストに変換される。

# In[45]:


list(tpl)


# 次に辞書を考えてみよう。

# In[46]:


dic = {'a':1,'b':2,'c':3}
dic


# この場合は，キーだけが抽出されリストが作成される。

# In[47]:


list(dic)


# ````{note}
# 次のコードでも辞書のキーからリストを作成することができる。
# ```
# list(dic.keys())
# ```
# また辞書の値からリストを作成するには次のコードを使うことができる。
# ```
# list(dic.values())
# ```
# ここで`.keys()`と`.values()`は`dic`のメソッドと呼ばれるものであり，下でより詳しく説明する。
# ````

# #### メソッド

# 全てのリストにはリスト自体に働きかける関数が備わっており，それをメソッドと呼ぶ。より詳細な説明は後に回すとして，ここではリストの最後に要素を追加する`append()`というメソッドを紹介する。空のリストを考えよう。

# In[48]:


lst = []


# 次の構文となる。
# ```
# lst.append(＜追加する要素＞)
# ```
# ここで`.`はメソッドにアクセスするための記号であり，その後にメソッド`append()`を置く。では`100`を`lst`に追加してみよう。

# In[49]:


lst.append(100)


# 何も表示されないが，`lst`は変更されている。`lst`を実行すると`100`が追加されていることが確認できる。

# In[50]:


lst


# 次は`50`を追加しよう。

# In[51]:


lst.append(50)

lst


# `append()`以外にも色々なメソッドが備わっている。

# ### タプル

# #### 説明

# まず次の様に`tpl1`と`tpl2`を定義しよう。

# In[52]:


tpl1 = (10, 20, 30, 40, ('a', 'b'))


# In[53]:


tpl2 = ((1,2,3),
        (4,5,6),
        (7,8,9))


# タプルのリストとの違いは，要素を変更できないということである。その他は殆ど同じなので，次のことが言える。
# * １つの要素の抽出：リストと同じ
#     * 例えば，`tpl1[0]`は`10`を返す。
# * 複数要素の抽出（スライシング）：リストと同じ
#     * 例えば，`tpl1[1:3+1]`は`(20, 30, 40)`を返す。
# * ２次元タプルの要素抽出：リストと同じ
#     * 例えば，`tpl[1][0]`は`4`を返す。
# * 要素の入れ替え：不可
#     * 例えば，`tpl[1] = 0`を実行するとエラーが発生する。
# * 要素の削除：不可
#     * 例えば，`del tpl[1]`を実行するとエラーが発生する。

# #### 他のコンテナデータ型からリストへの変換

# * 関数`tuple()`を使う。
# 
# この関数も`list()`と非常に似ている。次のリストを考えよう。

# In[54]:


lst = [1, 3.14, 'A']
lst


# In[55]:


tuple(lst)


# 辞書の場合はキーのタプルとなる。

# In[56]:


dic = {'a':1,'b':2,'c':3}
tuple(dic)


# ````{note}
# 次のコードでも辞書のキーからタプルを作成することができる。
# ```
# tuple(dic.keys())
# ```
# また辞書の値からタプルを作成するには次のコードを使うことができる。
# ```
# tuple(dic.values())
# ```
# ここで`.keys()`と`.values()`は`dic`のメソッドと呼ばれるものであり，下でより詳しく説明する。
# ````

# ### 辞書

# #### 要素の抽出

# 次の例を考えよう。

# In[57]:


macro = {'inflation':2, 'unemployment':5, 'interest_rate': 3}


# `0`番目の要素は`inflation`（インフレ）と`2`（％）には２つのペアであり，`1`番目の要素は`unemployment`（失業）と`5`（％）のペアとなっている。辞書の場合，要素にアクセスするには`0`や`1`のインデックス番号を使わずに，キーを指定しペアとなる値を抽出する。その際，リストとタプルと同じように`[]`を使う。`inflation`の`2`にアクセスしてみよう。

# In[58]:


macro['inflation']


# 同様に`unemployment`の値にアクセスするには次の様にする。

# In[59]:


macro['unemployment']


# 辞書にスライシングはない。

# #### 入れ子の場合の抽出

# 次の例を考えよう。

# In[60]:


dic2 = {'AB':{'a':1, 'b':2,}, 'C':[10, 20]}


# 次のコードで`AB`の値を抽出できることは理解できるだろう。

# In[61]:


dic3 = dic2['AB']
dic3


# 更に，`b`の値`2`にアクセスしたいとしよう。その場合は，

# In[62]:


dic3['b']


# とすれば良い。２つのコードを一緒に書くと次の様になる。

# In[63]:


dic2['AB']['b']


# 同じ要領で，`20`にアクセスしてみよう。

# In[64]:


dic2['C'][1]


# どれだけ入れ子になっていても`[]`を連続させることによって目的の要素にアクセスできることが分かると思う。

# #### 値の入れ替え

# 辞書はキーと値のペアとなっているが，変更できるのは値だけである。方法はリストと同じで，`=`の左辺に変更したいキーを選び，右辺に変更後の値を配置し実行するだけである。例えば，`macro`にある`unemployment`の値を`10.5`に入れ替えてみよう。

# In[65]:


macro['unemployment'] = 10.5
macro


# #### 要素の削除

# どうしてもキーを変更したい場合は，キー・値のペアを削除し，新たに追加することになる。例えば，`'unemployment':10.5`を`'失業率':10.5`に「変更」するには次のコードとなる。

# In[66]:


del macro['unemployment']  # 1

macro['失業率'] = 10.5      # 2

macro                      # 3


# * １行目で`'unemployment':10.5`を削除している，ここでの`del`はリストの要素を削除した際に使った同じ`del`である。
# * ２行目で`'失業率':10.5`を追加している。
# * ３行目は`macro`を実行して内容を表示している。

# #### メソッド

# リスト同様，全ての辞書には様々なメソッドが備わっている。ここでは２つを紹介する。
# * `keys()`：キーを抽出するメソッド
# * `values()`：値を抽出するメソッド
# 
# まず`macro`を使って`keys()`から考えよう。

# In[67]:


mkey = macro.keys()
mkey


# ３つのキーが並んでいるのが確認できる。一方で表示の最初に`dict_keys`と書かれており，リストやタプルと異なる様である。データ型を確認してみよう。

# In[68]:


type(mkey)


# `dict_keys`というデータ型であり，やはりリストやタプルとは異なる。リストに変換するには関数`list()`を使えば良い。

# In[69]:


list(mkey)


# 同様にタプルに変換するには`tuple()`を使う。
# 
# 次にメソッド`values()`を考えよう。

# In[70]:


mval = macro.values()

mval, type(mval)


# `dict_values`というデータ型となっている。リストに変換するには次のコードとなる。

# In[71]:


list(mval)


# ## 文字列の操作

# ### 文字の抽出

# ここではコンテナデータ型の次の操作について説明する。
# * 要素の抽出（アクセス）
# * 基本的なメソッド
# 
# `Python`の文字列には6つのアルファベット文字が，それぞれを
# 
# 次の文字列を考えよう。

# In[72]:


s = 'It is fun to learn Python!'


# `s`にはアルファベットと半角スペースが使われているが，それぞれが要素となる文字列である。従って，リスト同様`[]`を使って文字を抽出することができる。`0`番目と最後の文字は次のコードでアクセスできる。

# In[73]:


s[0], s[-1]


# スライシングも使える。

# In[74]:


s[3:10+1]


# ### 文字列は変更不可

# タプル同様，文字列は変更不可となるため次の操作はできない。
# * 要素の入れ替え
# * 要素の削除
# 
# `s`の`Python`を`economics`に変更するには，新しい文字列を`s`に再割り当てすることになる。

# In[75]:


s = 'It is fun to learn economics!'


# ### `list()`と`tuple()`を使う

# 文字列に`list()`や`tuple()`を使うと，１つの文字が要素となるリストもしくはタプルを返すことになる。

# In[76]:


list('Python')


# In[77]:


tuple('Python')


# ### メソッド

# 全ての文字列には色々なメソッドが準備されている。ここでは３つ紹介する。
# * `split()`：デフォルトでは半角スペースで分割しリストを返す。
# * `join()`：文字列を結合する。
# * `replace()`：文字列を入れ替える。
# 
# `s`に`split()`を使ってみよう。

# In[78]:


s.split()


# デフォルトでは区切りに半角スペースが使われ，単語がリストの構成要素となっている。`()`に分割に使う文字列を指定することもできる。例えば，`is`で分割してみよう。

# In[79]:


s.split('is')


# この場合`is`が区切りとなり，`s`は２つに分かれている。
# 
# 次に`join()`を説明しよう。次の構文となる。
# ```
# '＜結合に使う文字列＞'.join(＜文字列が含まれるリスト・タプル＞)
# ```
# まずリストを作成して説明しよう。

# In[80]:


s_new = ['P','y','t','h','o','n']


# In[81]:


'-'.join(s_new)


# それぞれの文字が`-`で結合されているのがわかる。次も同じ結果を返す。

# In[82]:


'-'.join('Python')


# これは
# ```
# '-'.join( list('Python') )
# ```
# と同じことであり，`list()`が自動的に適応されていることが分かる。
# 
# `'-'.join(s_new)`の`s_new`の代わりに`s`を使ってみよう。

# In[83]:


'-'.join(s)


# 半角スペースを含めて全ての文字の間に`-`が入っている。単語の間にだけ`-`が入るようにするには次のコードで可能である。

# In[84]:


'-'.join( s.split() )


# `s.split()`で単語からなるリストを作成した後に`join()`で結合している。
# 
# メソッド`replace()`を使っても同じ結果を得ることができる。

# In[85]:


s.replace(' ', '-')


# * 第１引数`' '`：入れ替える対象の文字列
# * 第２引数`'-'`：入れ替える文字列

# In[86]:


s.replace(' ', '😁').replace('!', '‼️')


# ## まとめ

# **＜基本データ型の変換＞**
# 
# |   関数 | 動作  |
# | ----------- | ------- |
# | `list()` | リストへ変換 |
# | `tuple()` | タプルへ変換 |
# | `str()` | 文字列へ変換 |
# | `bool()` | 真偽値の確認 |

# **＜要素アクセス＞**
# 
# |     データ型 | 例       | 抽出方法 |
# | ----------- | ------- |---|
# | リスト | `x = [0,10,30]`    |  `x[1]`　→　`10` |
# | タプル | `y = (0,10,30)`    |  `y[1]`　→　`10` |
# | 辞書 | `z = {'a':0, 'b':10}` |  `z['b']`　→　`10` |

# **＜スライシング＞**
# 
# |     データ型 | 例       | 抽出方法 |
# | ----------- | ------- |---|
# | リスト | `x = [0,10,20,30]`    |  `x[:2+1]`　→　`[0,10,20]` |
# | リスト | `x = [0,10,20,30]`    |  `x[1:]`　→　`[10,20,30]` |
# | リスト | `x = [0,10,20,30]`    |  `x[:]`　→　`[0,10,20,30]` |
# | リスト | `x = [0,10,20,30]`    |  `x[::-1]`　→　`[30,20,10,0]` |
# 
# * 基本的にタプルも同じ

# **＜値の入れ替え＞**
# 
# |     データ型 | 例       | 方法 |
# | ----------- | ------- |---|
# | リスト | `x = [0,10,30]`    |  `x[1]=100` |
# | タプル | `y = (0,10,30)`    |  不可 |
# | 辞書 | `z = {'a':0, 'b':10}` |  `z['b']=100` |
# 
# 

# **＜要素の削除＞**
# 
# |     データ型 | 例       | 削除方法 |
# | ----------- | ------- |---|
# | リスト | `x = [0,10,30]` |  `del x[1]`　→　`[0,30]` |
# | タプル | `y = (0,10,30)` |  不可 |
# | 辞書 | `z = {'a':0,'b':10}` |  `del z['a']`　→　`{'b':10}` |

# **＜メソッド＞**
# 
# |     データ型 |　例      | メソッド |
# | ----------- | ------- |---|
# | リスト | `x = [10]` |  `x.append(20)`　→　`[10,20]` |
# | 辞書 | `x = {'a':0,'b':10}` |  `list( x.keys() )`　→　`['a','b']` |
# | 辞書 | `x = {'a':0,'b':10}` |  `list( x.values() )`　→　`[0,10]` |
# | 文字列 | `x = 'It is me!'` |  `x.split() )`　→　`['It','is','me!']` |
# | 文字列 | `x = ['It','is','me!']` |  `'-'.join(x) )`　→　`'It-is-me.'` |
# | 文字列 | `x = 'It is me!'` |  `x.replace(' ','-') )`　→　`'It-is-me.'` |
